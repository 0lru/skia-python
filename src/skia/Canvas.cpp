#include "common.h"
#include <pybind11/numpy.h>
#include <pybind11/stl.h>

template<typename T>
using NumPy = py::array_t<T, py::array::c_style | py::array::forcecast>;

void initCanvas(py::module &m) {
py::class_<SkAutoCanvasRestore>(m, "AutoCanvasRestore", R"docstring(
    Stack helper class calls :py:meth:`Canvas.restoreToCount` when
    :py:class:`AutoCanvasRestore` goes out of scope.

    Use this to guarantee that the canvas is restored to a known state.

    Example::

        with skia.AutoCanvasRestore(canvas):
            canvas.drawCircle(50., 50., 10., paint)

    )docstring")
    .def(py::init<SkCanvas*, bool>(),
        R"docstring(
        Preserves :py:meth:`Canvas.save` count.

        Optionally saves SkCanvas clip and SkCanvas matrix.

        :param skia.Canvas canvas: :py:class:`Canvas` to guard
        :param bool doSave: call :py:meth:`Canvas.save`
        :return: utility to restore :py:class:`Canvas` state on destructor
        )docstring",
        py::arg("canvas"), py::arg("doSave") = true)
    .def("restore", &SkAutoCanvasRestore::restore,
        R"docstring(
        Restores :py:class:`Canvas` to saved state immediately.

        Subsequent calls and destructor have no effect.
        )docstring")
    .def("__enter__", [] (SkAutoCanvasRestore& self) { return; })
    .def("__exit__", [] (SkAutoCanvasRestore& self, py::args args) {
        self.restore();
    })
    ;

py::enum_<SkClipOp>(m, "ClipOp")
    .value("kDifference", SkClipOp::kDifference)
    .value("kIntersect", SkClipOp::kIntersect)
    .value("kExtraEnumNeedInternallyPleaseIgnoreWillGoAway2",
        SkClipOp::kExtraEnumNeedInternallyPleaseIgnoreWillGoAway2)
    .value("kExtraEnumNeedInternallyPleaseIgnoreWillGoAway3",
        SkClipOp::kExtraEnumNeedInternallyPleaseIgnoreWillGoAway3)
    .value("kExtraEnumNeedInternallyPleaseIgnoreWillGoAway4",
        SkClipOp::kExtraEnumNeedInternallyPleaseIgnoreWillGoAway4)
    .value("kExtraEnumNeedInternallyPleaseIgnoreWillGoAway5",
        SkClipOp::kExtraEnumNeedInternallyPleaseIgnoreWillGoAway5)
    .value("kMax_EnumValue", SkClipOp::kMax_EnumValue)
    .export_values();

py::class_<SkCanvas> canvas(m, "Canvas", R"docstring(
    :py:class:`Canvas` provides an interface for drawing, and how the drawing is
    clipped and transformed.

    :py:class:`Canvas` contains a stack of :py:class:`Matrix` and clip values.

    :py:class:`Canvas` and :py:class:`Paint` together provide the state to draw
    into :py:class:`Surface` or SkBaseDevice. Each :py:class:`Canvas` draw call
    transforms the geometry of the object by the concatenation of all
    :py:class:`Matrix` values in the stack. The transformed geometry is clipped
    by the intersection of all of clip values in the stack. The
    :py:class:`Canvas` draw calls use :py:class:`Paint` to supply drawing state
    such as color, :py:class:`Typeface`, text size, stroke width,
    :py:class:`Shader` and so on.

    To draw to a pixel-based destination, create raster surface or GPU surface.
    Request :py:class:`Canvas` from :py:class:`Surface` to obtain the interface
    to draw. :py:class:`Canvas` generated by raster surface draws to memory
    visible to the CPU. :py:class:`Canvas` generated by GPU surface uses Vulkan
    or OpenGL to draw to the GPU.

    To draw to a document, obtain :py:class:`Canvas` from SVG canvas, document
    PDF, or :py:class:`PictureRecorder`. SkDocument based :py:class:`Canvas`
    and other :py:class:`Canvas` subclasses reference SkBaseDevice describing
    the destination.

    :py:class:`Canvas` can be constructed to draw to :py:class:`Bitmap` without
    first creating raster surface. This approach may be deprecated in the
    future.

    .. rubric:: Classes

    .. autosummary::
        :nosignatures:

        Canvas.SrcRectConstraint
        Canvas.PointMode
        Canvas.QuadAAFlags
        Canvas.SaveLayerRec
        Canvas.Lattice

    )docstring");

py::enum_<SkCanvas::SrcRectConstraint>(canvas, "SrcRectConstraint")
    .value("kStrict", SkCanvas::SrcRectConstraint::kStrict_SrcRectConstraint)
    .value("kFast", SkCanvas::SrcRectConstraint::kFast_SrcRectConstraint)
    .export_values();

py::enum_<SkCanvas::PointMode>(canvas, "PointMode")
    .value("kPoints", SkCanvas::PointMode::kPoints_PointMode)
    .value("kLines", SkCanvas::PointMode::kLines_PointMode)
    .value("kPolygon", SkCanvas::PointMode::kPolygon_PointMode)
    .export_values();

py::enum_<SkCanvas::QuadAAFlags>(canvas, "QuadAAFlags")
    .value("kLeft", SkCanvas::QuadAAFlags::kLeft_QuadAAFlag)
    .value("kTop", SkCanvas::QuadAAFlags::kTop_QuadAAFlag)
    .value("kRight", SkCanvas::QuadAAFlags::kRight_QuadAAFlag)
    .value("kBottom", SkCanvas::QuadAAFlags::kBottom_QuadAAFlag)
    .value("kNone", SkCanvas::QuadAAFlags::kNone_QuadAAFlags)
    .value("kAll", SkCanvas::QuadAAFlags::kAll_QuadAAFlags)
    .export_values();

py::class_<SkCanvas::SaveLayerRec> savelayerrec(canvas, "SaveLayerRec",
    R"docstring(
    SaveLayerRec contains the state used to create the layer.
    )docstring");

savelayerrec
    .def(py::init(),
        "Sets fBounds, fPaint, and fBackdrop to nullptr.")
    .def(py::init<const SkRect*, const SkPaint*, SkCanvas::SaveLayerFlags>(),
        "Sets fBounds, fPaint, and fSaveLayerFlags; sets fBackdrop to nullptr.")
    .def(py::init<const SkRect*, const SkPaint*, const SkImageFilter*,
        SkCanvas::SaveLayerFlags>(),
        "Sets fBounds, fPaint, fBackdrop, and fSaveLayerFlags.")
    .def(py::init<const SkRect*, const SkPaint*, const SkImageFilter*,
        const SkImage*, const SkMatrix*, SkCanvas::SaveLayerFlags>(),
        "Experimental.")
    .def_readwrite("fBounds", &SkCanvas::SaveLayerRec::fBounds,
        "hints at layer size limit",
        py::return_value_policy::reference)
    .def_readwrite("fPaint", &SkCanvas::SaveLayerRec::fPaint,
        "modifies overlay",
        py::return_value_policy::reference)
    .def_readwrite("fBackdrop", &SkCanvas::SaveLayerRec::fBackdrop,
        "If not null, this triggers the same initialization behavior as "
        "setting kInitWithPrevious_SaveLayerFlag on fSaveLayerFlags: the "
        "current layer is copied into the new layer, rather than initializing "
        "the new layer with transparent-black.",
        py::return_value_policy::reference)
    .def_readwrite("fClipMask", &SkCanvas::SaveLayerRec::fClipMask,
        "clips layer with mask alpha",
        py::return_value_policy::reference)
    .def_readwrite("fClipMatrix", &SkCanvas::SaveLayerRec::fClipMatrix,
        "transforms mask alpha used to clip",
        py::return_value_policy::reference)
    .def_readwrite("fSaveLayerFlags", &SkCanvas::SaveLayerRec::fSaveLayerFlags,
        "preserves LCD text, creates with prior layer contents")
    ;

py::class_<SkCanvas::Lattice> lattice(canvas, "Lattice", R"docstring(
    :py:class:`Canvas.Lattice` divides :py:class:`Bitmap` or :py:class:`Image`
    into a rectangular grid.

    Grid entries on even columns and even rows are fixed; these entries are
    always drawn at their original size if the destination is large enough. If
    the destination side is too small to hold the fixed entries, all fixed
    entries are proportionately scaled down to fit. The grid entries not on even
    columns and rows are scaled to fit the remaining space, if any.
    )docstring");

lattice
    .def_readwrite("fXDivs", &SkCanvas::Lattice::fXDivs)
    .def_readwrite("fYDivs", &SkCanvas::Lattice::fYDivs)
    .def_readwrite("fRectTypes", &SkCanvas::Lattice::fRectTypes)
    .def_readwrite("fXCount", &SkCanvas::Lattice::fXCount)
    .def_readwrite("fYCount", &SkCanvas::Lattice::fYCount)
    .def_readwrite("fBounds", &SkCanvas::Lattice::fBounds)
    .def_readwrite("fColors", &SkCanvas::Lattice::fColors)
    ;

py::enum_<SkCanvas::Lattice::RectType>(lattice, "RectType")
    .value("kDefault", SkCanvas::Lattice::RectType::kDefault)
    .value("kTransparent", SkCanvas::Lattice::RectType::kTransparent)
    .value("kFixedColor", SkCanvas::Lattice::RectType::kFixedColor)
    .export_values();

canvas
    .def(py::init<>(),
        R"docstring(
        Creates an empty :py:class:`Canvas` with no backing device or pixels,
        with a width and height of zero.
        )docstring")
    .def(py::init([](NumPy<uint8_t> array) {
            py::buffer_info info = array.request();
            if (info.ndim != 3)
                throw std::runtime_error(
                    "Number of dimensions must be 2 or more.");
            if (info.shape[2] < 4)
                throw std::runtime_error("Color channels must be 4.");
            auto canvas = SkCanvas::MakeRasterDirectN32(
                info.shape[1], info.shape[0], static_cast<SkPMColor*>(info.ptr),
                info.strides[0]);
            if (!canvas)
                throw std::runtime_error("Failed to create Canvas");
            return canvas;
        }),
        R"docstring(
        Creates raster :py:class:`Canvas` backed by NumPy array.

        Subsequent :py:class:`Canvas` calls draw into pixels.
        :py:class:`ColorType` is set to :py:attr:`ColorType.kN32`.
        :py:class:`AlphaType` is set to :py:attr:`AlphaType.kPremul`. To access
        pixels after drawing, call flush() or peekPixels().

        :array: NumPy array of dtype = uint8 and dimensions
            (height, width, 4).
        )docstring",
        py::arg("array"))
    .def(py::init<int, int, const SkSurfaceProps*>(),
        R"docstring(
        Creates :py:class:`Canvas` of the specified dimensions without a
        :py:class:`Surface`.

        Used by subclasses with custom implementations for draw member
        functions.

        If props equals `None`, :py:class:`SurfaceProps` are created with
        :py:class:`SurfaceProps.InitType` settings, which choose the pixel
        striping direction and order. Since a platform may dynamically change
        its direction when the device is rotated, and since a platform may have
        multiple monitors with different characteristics, it is best not to rely
        on this legacy behavior.

        :width: zero or greater
        :height: zero or greater
        :props: LCD striping orientation and setting for device independent
            fonts; may be `None`
        )docstring",
        py::arg("width"), py::arg("height"), py::arg("props") = nullptr)
    .def(py::init<const SkBitmap&>(),
        R"docstring(
        Constructs a canvas that draws into bitmap.

        Sets :py:attr:`SurfaceProps.kLegacyFontHost` in constructed
        :py:class:`Surface`.

        :py:class:`Bitmap` is copied so that subsequently editing bitmap will
        not affect constructed :py:class:`Canvas`.

        May be deprecated in the future.

        :bitmap: width, height, :py:class:`ColorType`, :py:class:`AlphaType`,
            and pixel storage of raster surface
        )docstring",
        py::arg("bitmap"))
    .def(py::init<const SkBitmap&, const SkSurfaceProps&>(),
        R"docstring(
        Constructs a canvas that draws into bitmap.

        Use props to match the device characteristics, like LCD striping.

        bitmap is copied so that subsequently editing bitmap will not affect
        constructed :py:class:`Canvas`.

        :bitmap: width, height, :py:class:`ColorType`, :py:class:`AlphaType`,
            and pixel storage of raster surface
        :props: order and orientation of RGB striping; and whether to use device
            independent fonts
        )docstring",
        py::arg("bitmap"), py::arg("props"))
    .def("imageInfo", &SkCanvas::imageInfo,
        R"docstring(
        Returns :py:class:`ImageInfo` for :py:class:`Canvas`.

        If :py:class:`Canvas` is not associated with raster surface or GPU
        surface, returned :py:class:`ColorType` is set to
        :py:attr:`ColorType.kUnknown`.

        :return: dimensions and :py:class:`ColorType` of :py:class:`Canvas`
        )docstring")
    .def("getProps", &SkCanvas::getProps,
        R"docstring(
        Copies :py:class:`SurfaceProps`, if :py:class:`Canvas` is associated
        with raster surface or GPU surface, and returns true.

        Otherwise, returns false and leave props unchanged.

        :param skia.SurfaceProps props: storage for writable SurfaceProps
        :return: true if :py:class:`SurfaceProps` was copied
        )docstring",
        py::arg("props"))
    .def("flush", &SkCanvas::flush,
        R"docstring(
        Triggers the immediate execution of all pending draw operations.

        If :py:class:`Canvas` is associated with GPU surface, resolves all
        pending GPU operations. If :py:class:`Canvas` is associated with raster
        surface, has no effect; raster draw operations are never deferred.
        )docstring")
    .def("getBaseLayerSize", &SkCanvas::getBaseLayerSize,
        R"docstring(
        Gets the size of the base or root layer in global canvas coordinates.

        The origin of the base layer is always (0,0). The area available for
        drawing may be smaller (due to clipping or saveLayer).

        :return: integral width and height of base layer
        :rtype: skia.ISize
        )docstring")
    .def("makeSurface", &SkCanvas::makeSurface,
        R"docstring(
        Creates :py:class:`Surface` matching info and props, and associates it
        with :py:class:`Canvas`.

        Returns nullptr if no match found.

        If props is nullptr, matches :py:class:`SurfaceProps` in
        :py:class:`Canvas`. If props is nullptr and :py:class:`Canvas` does not
        have :py:class:`SurfaceProps`, creates :py:class:`Surface` with default
        :py:class:`SurfaceProps`.

        :param skia.ImageInfo info: width, height, :py:class:`ColorType`,
            :py:class:`AlphaType`, and :py:class:`ColorSpace`
        :param skia.SurfaceProps props: :py:class:`SurfaceProps` to match; may
            be nullptr to match :py:class:`Canvas`
        :return: SkSurface matching info and props, or nullptr if no match is
            available
        :rtype: skia.Surface or None
        )docstring",
        py::arg("info"), py::arg("props") = nullptr)
    .def("getGrContext", &SkCanvas::getGrContext,
        R"docstring(
        Returns GPU context of the GPU surface associated with
        :py:class:`Canvas`.

        :return: GPU context, if available; nullptr otherwise
        :rtype: skia.GrContext or None
        )docstring",
        py::return_value_policy::reference)
    .def("getSurface", &SkCanvas::getSurface,
        R"docstring(
        Sometimes a canvas is owned by a surface.

        If it is, getSurface() will return a bare pointer to that surface, else
        this will return nullptr.

        :rtype: skia.Surface or None
        )docstring",
        py::return_value_policy::reference)
    // .def("accessTopLayerPixels", &SkCanvas::accessTopLayerPixels,
    //     "Returns the pixel base address, SkImageInfo, rowBytes, and origin if "
    //     "the pixels can be read directly.",
    //     py::return_value_policy::reference)
    // .def("accessTopRasterHandle", &SkCanvas::accessTopRasterHandle,
    //     "Returns custom context that tracks the SkMatrix and clip.")
    .def("peekPixels", &SkCanvas::peekPixels,
        R"docstring(
        Returns true if :py:class:`Canvas` has direct access to its pixels.

        Pixels are readable when :py:class:`BaseDevice` is raster. Pixels are
        not readable when :py:class:`Canvas` is returned from GPU surface,
        returned by :py:meth:`Document.beginPage`, returned by
        :py:meth:`PictureRecorder.beginRecording`, or :py:class:`Canvas` is
        the base of a utility class like DebugCanvas.

        pixmap is valid only while :py:class:`Canvas` is in scope and unchanged.
        Any :py:class:`Canvas` or :py:class:`Surface` call may invalidate the
        pixmap values.

        :param skia.Pixmap pixmap: storage for pixel state if pixels are
            readable; otherwise, ignored
        :return: true if :py:class:`Canvas` has direct access to pixels
        :rtype: bool
        )docstring",
        py::arg("pixmap"))
    .def("readPixels",
        // py::overload_cast<const SkImageInfo&, void*, size_t, int, int>(
        //     &SkCanvas::readPixels),
        [] (SkCanvas& canvas, NumPy<uint8_t> array, int srcX, int srcY) {
            py::buffer_info info = array.request();
            if (info.ndim <= 2)
                throw std::runtime_error(
                    "Number of dimensions must be 3 or more.");
            if (info.shape[2] < 4)
                throw std::runtime_error("Color channels must be 4.");
            auto imageinfo = SkImageInfo::MakeN32Premul(
                info.shape[1], info.shape[0]);
            return canvas.readPixels(
                imageinfo, info.ptr, info.strides[0], srcX, srcY);
        },
        R"docstring(
        Copies :py:class:`Rect` of pixels from :py:class:`Canvas` into array.

        :py:class:`Matrix` and clip are ignored.

        Source :py:class:`Rect` corners are (srcX, srcY) and (
        imageInfo().width(), imageInfo().height()). Destination :py:class:`Rect`
        corners are (0, 0) and (array.shape[1], array.shape[0]). Copies each
        readable pixel intersecting both rectangles, without scaling, converting
        to :py:attr:`ColorType.kN32` and :py:attr:`AlphaType.kPremul` if
        required.

        Pixels are readable when :py:class:`BaseDevice` is raster, or backed by
        a GPU. Pixels are not readable when :py:class:`Canvas` is returned by
        :py:meth:`Document.beginPage`, returned by
        :py:meth:`PictureRecorder.beginRecording`, or :py:class:`Canvas` is the
        base of a utility class like DebugCanvas.

        The destination pixel storage must be allocated by the caller.

        Pixel values are converted only if :py:class:`ColorType` and
        :py:class:`AlphaType` do not match. Only pixels within both source and
        destination rectangles are copied. array contents outside
        :py:class:`Rect` intersection are unchanged.

        Pass negative values for srcX or srcY to offset pixels across or down
        destination.

        Does not copy, and returns false if:

        - Source and destination rectangles do not intersect.
        - :py:class:`Canvas` pixels could not be converted to
            :py:attr:`ColorType.kN32` or :py:attr:`AlphaType.kPremul`.
        - :py:class:`Canvas` pixels are not readable; for instance,
        - :py:class:`Canvas` is document-based.

        :array: storage for pixels
        :srcX: offset into readable pixels on x-axis; may be negative
        :srcY: offset into readable pixels on y-axis; may be negative
        :return: true if pixels were copied
        )docstring",
        py::arg("array"), py::arg("srcX") = 0, py::arg("srcY") = 0)
    .def("readPixels",
        py::overload_cast<const SkPixmap&, int, int>(&SkCanvas::readPixels),
        R"docstring(
        Copies :py:class:`Rect` of pixels from :py:class:`Canvas` into pixmap.

        :py:class:`Matrix` and clip are ignored.

        Source :py:class:`Rect` corners are (srcX, srcY) and (
        imageInfo().width(), imageInfo().height()). Destination
        :py:class:`Rect` corners are (0, 0) and (pixmap.width(),
        pixmap.height()). Copies each readable pixel intersecting both
        rectangles, without scaling, converting to pixmap.colorType() and
        pixmap.alphaType() if required.

        Pixels are readable when :py:class:`BaseDevice` is raster, or backed by
        a GPU. Pixels are not readable when :py:class:`Canvas` is returned by
        :py:meth:`Document.beginPage`, returned by
        :py:meth:`PictureRecorder.beginRecording`, or :py:class:`Canvas` is the
        base of a utility class like DebugCanvas.

        Caller must allocate pixel storage in pixmap if needed.

        Pixel values are converted only if :py:class:`ColorType` and
        :py:class:`AlphaType` do not match. Only pixels within both source and
        destination :py:class:`Rect` are copied. pixmap pixels contents outside
        :py:class:`Rect` intersection are unchanged.

        Pass negative values for srcX or srcY to offset pixels across or down
        pixmap.

        Does not copy, and returns false if:

        - Source and destination rectangles do not intersect.
        - :py:class:`Canvas` pixels could not be converted to
            pixmap.colorType() or pixmap.alphaType().
        - :py:class:`Canvas` pixels are not readable; for instance,
            :py:class:`Canvas` is document-based.
        - :py:class:`Pixmap` pixels could not be allocated.
        - pixmap.rowBytes() is too small to contain one row of pixels.

        :pixmap: storage for pixels copied from
            :py:class:`Canvas`
        :srcX: offset into readable pixels on x-axis; may be negative
        :srcY: offset into readable pixels on y-axis; may be negative
        :return: true if pixels were copied
        )docstring",
        py::arg("pixmap"), py::arg("srcX") = 0, py::arg("srcY") = 0)
    .def("readPixels",
        py::overload_cast<const SkBitmap&, int, int>(&SkCanvas::readPixels),
        R"docstring(
        Copies :py:class:`Rect` of pixels from :py:class:`Canvas` into bitmap.

        :py:class:`Matrix` and clip are ignored.

        Source :py:class:`Rect` corners are (srcX, srcY) and (
        imageInfo().width(), imageInfo().height()). Destination
        :py:class:`Rect` corners are (0, 0) and (bitmap.width(),
        bitmap.height()). Copies each readable pixel intersecting both
        rectangles, without scaling, converting to bitmap.colorType() and
        bitmap.alphaType() if required.

        Pixels are readable when :py:class:`BaseDevice` is raster, or backed by
        a GPU. Pixels are not readable when :py:class:`Canvas` is returned by
        :py:meth:`Document.beginPage`, returned by
        :py:meth:`PictureRecorder.beginRecording`, or :py:class:`Canvas` is the
        base of a utility class like DebugCanvas.

        Caller must allocate pixel storage in bitmap if needed.

        :py:class:`Bitmap` values are converted only if :py:class:`ColorType`
        and :py:class:`AlphaType` do not match. Only pixels within both source
        and destination rectangles are copied. :py:class:`Bitmap` pixels outside
        :py:class:`Rect` intersection are unchanged.

        Pass negative values for srcX or srcY to offset pixels across or down
        bitmap.

        Does not copy, and returns false if:

        - Source and destination rectangles do not intersect.
        - :py:class:`Canvas` pixels could not be converted to bitmap.colorType()
            or bitmap.alphaType().
        - :py:class:`Canvas` pixels are not readable; for instance,
            :py:class:`Canvas` is document-based.
        - bitmap pixels could not be allocated.
        - bitmap.rowBytes() is too small to contain one row of pixels.

        :bitmap: storage for pixels copied from
            :py:class:`Canvas`
        :srcX: offset into readable pixels on x-axis; may be negative
        :srcY: offset into readable pixels on y-axis; may be negative

        :return: true if pixels were copied
        )docstring",
        py::arg("bitmap"), py::arg("srcX") = 0, py::arg("srcY") = 0)
    .def("writePixels",
        // py::overload_cast<const SkImageInfo&, const void*, size_t, int, int>(
        //     &SkCanvas::writePixels),
        [] (SkCanvas& canvas, NumPy<uint8_t> array, int x, int y) {
            py::buffer_info info = array.request();
            if (info.ndim <= 1)
                throw std::runtime_error(
                    "Number of dimensions must be 2 or more.");
            if (info.shape[0] == 0 || info.shape[1] == 0)
                throw std::runtime_error(
                    "Width and height must be greater than 0.");
            auto imageinfo = SkImageInfo::MakeN32Premul(
                info.shape[1], info.shape[0]);
            return canvas.writePixels(
                imageinfo, info.ptr, info.strides[0], x, y);
        },
        "Copies SkRect from pixels to SkCanvas.",
        py::arg("array"), py::arg("x") = 0, py::arg("y") = 0)
    .def("writePixels",
        py::overload_cast<const SkBitmap&, int, int>(&SkCanvas::writePixels),
        "Copies SkRect from pixels to SkCanvas.")
    .def("save", &SkCanvas::save, "Saves SkMatrix and clip.")
    .def("saveLayer",
        py::overload_cast<const SkRect*, const SkPaint*>(&SkCanvas::saveLayer),
        "Saves SkMatrix and clip, and allocates a SkBitmap for subsequent "
        "drawing.")
    .def("saveLayer",
        py::overload_cast<const SkRect&, const SkPaint*>(&SkCanvas::saveLayer),
        "Saves SkMatrix and clip, and allocates a SkBitmap for subsequent "
        "drawing.")
    .def("saveLayerAlpha", &SkCanvas::saveLayerAlpha,
        "Saves SkMatrix and clip, and allocates SkBitmap for subsequent "
        "drawing.")
    .def("saveLayer",
        py::overload_cast<const SkCanvas::SaveLayerRec&>(&SkCanvas::saveLayer),
        "Saves SkMatrix and clip, and allocates a SkBitmap for subsequent "
        "drawing.")
    .def("experimental_saveCamera",
        py::overload_cast<const SkM44&, const SkM44&>(
            &SkCanvas::experimental_saveCamera))
    .def("experimental_saveCamera",
        py::overload_cast<const SkScalar[16], const SkScalar[16]>(
            &SkCanvas::experimental_saveCamera))
    .def("restore", &SkCanvas::restore,
        "Removes changes to SkMatrix and clip since SkCanvas state was last "
        "saved.")
    .def("getSaveCount", &SkCanvas::getSaveCount,
        "Returns the number of saved states, each containing: SkMatrix and "
        "clip.")
    .def("restoreToCount", &SkCanvas::restoreToCount,
        "Restores state to SkMatrix and clip values when save(), saveLayer(), "
        "saveLayerPreserveLCDTextRequests(), or saveLayerAlpha() returned "
        "saveCount.")
    .def("translate", &SkCanvas::translate,
        "Translates SkMatrix by dx along the x-axis and dy along the y-axis.")
    .def("scale", &SkCanvas::scale,
        "Scales SkMatrix by sx on the x-axis and sy on the y-axis.")
    .def("rotate", py::overload_cast<SkScalar>(&SkCanvas::rotate),
        "Rotates SkMatrix by degrees.")
    .def("rotate",
        py::overload_cast<SkScalar, SkScalar, SkScalar>(&SkCanvas::rotate),
        "Rotates SkMatrix by degrees about a point at (px, py).")
    .def("skew", &SkCanvas::skew,
        "Skews SkMatrix by sx on the x-axis and sy on the y-axis.")
    .def("concat", &SkCanvas::concat,
        "Replaces SkMatrix with matrix premultiplied with existing SkMatrix.")
    .def("concat44", py::overload_cast<const SkM44&>(&SkCanvas::concat44))
    .def("concat44", py::overload_cast<const SkScalar[]>(&SkCanvas::concat44))
    .def("setMatrix", &SkCanvas::setMatrix, "Replaces SkMatrix with matrix.")
    .def("resetMatrix", &SkCanvas::resetMatrix,
        "Sets SkMatrix to the identity matrix.")
    .def("clipRect",
        py::overload_cast<const SkRect&, SkClipOp, bool>(&SkCanvas::clipRect),
        "Replaces clip with the intersection or difference of clip and rect, "
        "with an aliased or anti-aliased clip edge.")
    .def("clipRect",
        py::overload_cast<const SkRect&, SkClipOp>(&SkCanvas::clipRect),
        "Replaces clip with the intersection or difference of clip and rect.")
    .def("clipRect",
        py::overload_cast<const SkRect&, bool>(&SkCanvas::clipRect),
        "Replaces clip with the intersection of clip and rect.",
        py::arg("rect"), py::arg("doAntiAlias") = false)
    .def("androidFramework_setDeviceClipRestriction",
        &SkCanvas::androidFramework_setDeviceClipRestriction,
        "Sets the maximum clip rectangle, which can be set by clipRect(), "
        "clipRRect() and clipPath() and intersect the current clip with the "
        "specified rect.")
    .def("clipRRect",
        py::overload_cast<const SkRRect&, SkClipOp, bool>(&SkCanvas::clipRRect),
        "Replaces clip with the intersection or difference of clip and rrect, "
        "with an aliased or anti-aliased clip edge.")
    .def("clipRRect",
        py::overload_cast<const SkRRect&, SkClipOp>(&SkCanvas::clipRRect),
        "Replaces clip with the intersection or difference of clip and rrect.")
    .def("clipRRect",
        py::overload_cast<const SkRRect&, bool>(&SkCanvas::clipRRect),
        "Replaces clip with the intersection of clip and rrect, with an "
        "aliased or anti-aliased clip edge.",
        py::arg("rrect"), py::arg("doAntiAlias") = false)
    .def("clipPath",
        py::overload_cast<const SkPath&, SkClipOp, bool>(&SkCanvas::clipPath),
        "Replaces clip with the intersection or difference of clip and path, "
        "with an aliased or anti-aliased clip edge.")
    .def("clipPath",
        py::overload_cast<const SkPath&, SkClipOp>(&SkCanvas::clipPath),
        "Replaces clip with the intersection or difference of clip and path.")
    .def("clipPath",
        py::overload_cast<const SkPath&, bool>(&SkCanvas::clipPath),
        "Replaces clip with the intersection of clip and path.",
        py::arg("path"), py::arg("doAntiAlias") = false)
    // .def("clipShader", &SkCanvas::clipShader)
    .def("clipRegion", &SkCanvas::clipRegion,
        "Replaces clip with the intersection or difference of clip and "
        "SkRegion deviceRgn.",
        py::arg("deviceRgn"), py::arg("op") = SkClipOp::kIntersect)
    .def("quickReject",
        py::overload_cast<const SkRect&>(&SkCanvas::quickReject, py::const_),
        "Returns true if SkRect rect, transformed by SkMatrix, can be quickly "
        "determined to be outside of clip.")
    .def("quickReject",
        py::overload_cast<const SkPath&>(&SkCanvas::quickReject, py::const_),
        "Returns true if path, transformed by SkMatrix, can be quickly "
        "determined to be outside of clip.")
    .def("getLocalClipBounds",
        py::overload_cast<>(&SkCanvas::getLocalClipBounds, py::const_),
        "Returns bounds of clip, transformed by inverse of SkMatrix.")
    .def("getLocalClipBounds",
        py::overload_cast<SkRect*>(&SkCanvas::getLocalClipBounds, py::const_),
        "Returns bounds of clip, transformed by inverse of SkMatrix.")
    .def("getDeviceClipBounds",
        py::overload_cast<>(&SkCanvas::getDeviceClipBounds, py::const_),
        "Returns SkIRect bounds of clip, unaffected by SkMatrix.")
    .def("getDeviceClipBounds",
        py::overload_cast<SkIRect*>(&SkCanvas::getDeviceClipBounds, py::const_),
        "Returns SkIRect bounds of clip, unaffected by SkMatrix.")
    .def("drawColor", &SkCanvas::drawColor, "Fills clip with color color.",
        py::arg("color"), py::arg("mode") = SkBlendMode::kSrcOver)
    .def("clear", &SkCanvas::clear,
        R"docstring(
        Fills clip with color color using :py:attr:`BlendMode.kSrc`.

        This has the effect of replacing all pixels contained by clip with
        color.

        :param int color: unpremultiplied ARGB
        )docstring",
        py::arg("color"))
    .def("discard", &SkCanvas::discard, "Makes SkCanvas contents undefined.")
    .def("drawPaint", &SkCanvas::drawPaint, "Fills clip with SkPaint paint.")
    .def("drawPoints",
        // &SkCanvas::drawPoints,
        [] (SkCanvas& canvas, SkCanvas::PointMode mode, py::iterable iterable,
            const SkPaint &paint) {
            std::vector<SkPoint> points;
            for (auto point : iterable) {
                points.push_back(*point.cast<SkPoint*>());
            }
            canvas.drawPoints(mode, points.size(), &points[0], paint);
        },
        R"docstring(
        Draws pts using clip, :py:class:`Matrix` and :py:class:`Paint`
        paint.

        mode may be one of: :py:attr:`~Canvas.PointMode.kPoints`,
        :py:attr:`~Canvas.PointMode.kLines`, or
        :py:attr:`~Canvas.PointMode.kPolygon`.

        If mode is :py:attr:`kPoints`, the shape of point drawn depends on
        paint :py:class:`Paint.Cap`. If paint is set to :py:attr:`Paint.kRound`,
        each point draws a circle of diameter :py:class:`Paint` stroke width. If
        paint is set to :py:attr:`Paint.kSquare` or :py:attr:`Paint.kButt`, each
        point draws a square of width and height :py:attr:`Paint` stroke width.

        If mode is :py:attr:`kLines`, each pair of points draws a line segment.
        One line is drawn for every two points; each point is used once. If
        count is odd, the final point is ignored.

        If mode is :py:attr:`kPolygon`, each adjacent pair of points draws a
        line segment. count minus one lines are drawn; the first and last point
        are used once.

        Each line segment respects paint :py:class:`Paint.Cap` and
        :py:class:`Paint` stroke width. :py:class:`Paint.Style` is ignored, as
        if were set to :py:attr:`Paint.kStroke`.

        Always draws each element one at a time; is not affected by
        :py:class:`Paint.Join`, and unlike :py:meth:`drawPath`, does not create
        a mask from all points and lines before drawing.

        :param skia.Canvas.PointMode mode: whether pts draws points or lines
        :param Iterable[skia.Point] pts: array of points to draw
        :param skia.Paint paint: stroke, blend, color, and so on, used to draw
        )docstring",
        py::arg("mode"), py::arg("pts"), py::arg("paint"))
    .def("drawPoint",
        py::overload_cast<SkScalar, SkScalar, const SkPaint&>(
            &SkCanvas::drawPoint),
        "Draws point at (x, y) using clip, SkMatrix and SkPaint paint.")
    .def("drawPoint",
        py::overload_cast<SkPoint, const SkPaint&>(&SkCanvas::drawPoint),
        "Draws point p using clip, SkMatrix and SkPaint paint.")
    .def("drawLine",
        py::overload_cast<SkScalar, SkScalar, SkScalar, SkScalar,
            const SkPaint&>(&SkCanvas::drawLine),
        "Draws line segment from (x0, y0) to (x1, y1) using clip, SkMatrix, "
        "and SkPaint paint.")
    .def("drawLine",
        py::overload_cast<SkPoint, SkPoint, const SkPaint&>(
            &SkCanvas::drawLine),
        "Draws line segment from p0 to p1 using clip, SkMatrix, and SkPaint "
        "paint.")
    .def("drawRect", &SkCanvas::drawRect,
        "Draws SkRect rect using clip, SkMatrix, and SkPaint paint.")
    .def("drawIRect", &SkCanvas::drawIRect,
        "Draws SkIRect rect using clip, SkMatrix, and SkPaint paint.")
    .def("drawRegion", &SkCanvas::drawRegion,
        "Draws SkRegion region using clip, SkMatrix, and SkPaint paint.")
    .def("drawOval", &SkCanvas::drawOval,
        "Draws oval oval using clip, SkMatrix, and SkPaint.")
    .def("drawRRect", &SkCanvas::drawRRect,
        "Draws SkRRect rrect using clip, SkMatrix, and SkPaint paint.")
    .def("drawDRRect", &SkCanvas::drawDRRect,
        "Draws SkRRect outer and inner using clip, SkMatrix, and SkPaint "
        "paint.")
    .def("drawCircle",
        py::overload_cast<SkScalar, SkScalar, SkScalar, const SkPaint&>(
            &SkCanvas::drawCircle),
        "Draws circle at (cx, cy) with radius using clip, SkMatrix, and "
        "SkPaint paint.")
    .def("drawCircle",
        py::overload_cast<SkPoint, SkScalar, const SkPaint&>(
            &SkCanvas::drawCircle),
        "Draws circle at center with radius using clip, SkMatrix, and SkPaint "
        "paint.")
    .def("drawArc", &SkCanvas::drawArc,
        "Draws arc using clip, SkMatrix, and SkPaint paint.")
    .def("drawRoundRect", &SkCanvas::drawRoundRect,
        "Draws SkRRect bounded by SkRect rect, with corner radii (rx, ry) "
        "using clip, SkMatrix, and SkPaint paint.")
    .def("drawPath", &SkCanvas::drawPath,
        "Draws SkPath path using clip, SkMatrix, and SkPaint paint.")
    .def("drawImage",
        py::overload_cast<const SkImage*, SkScalar, SkScalar,
            const SkPaint*>(&SkCanvas::drawImage),
        "Draws SkImage image, with its top-left corner at (left, top), using "
        "clip, SkMatrix, and optional SkPaint paint",
        py::arg("image"), py::arg("left"), py::arg("top"),
        py::arg("paint") = nullptr)
    .def("drawImage",
        py::overload_cast<const sk_sp<SkImage>&, SkScalar, SkScalar,
            const SkPaint*>(&SkCanvas::drawImage),
        "Draws SkImage image, with its top-left corner at (left, top), using "
        "clip, SkMatrix, and optional SkPaint paint",
        py::arg("image"), py::arg("left"), py::arg("top"),
        py::arg("paint") = nullptr)
    .def("drawImageRect",
        py::overload_cast<const SkImage*, const SkRect&, const SkRect&,
            const SkPaint*, SkCanvas::SrcRectConstraint>(
                &SkCanvas::drawImageRect),
        "Draws SkRect src of SkImage image, scaled and translated to fill "
        "SkRect dst.",
        py::arg("image"), py::arg("src"), py::arg("dst"),
        py::arg("paint") = nullptr, py::arg("constraint") =
            SkCanvas::SrcRectConstraint::kStrict_SrcRectConstraint)
    .def("drawImageRect",
        py::overload_cast<const SkImage*, const SkIRect&, const SkRect&,
            const SkPaint*, SkCanvas::SrcRectConstraint>(
            &SkCanvas::drawImageRect),
        "Draws SkIRect isrc of SkImage image, scaled and translated to fill "
        "SkRect dst.",
        py::arg("image"), py::arg("isrc"), py::arg("dst"),
        py::arg("paint") = nullptr, py::arg("constraint") =
            SkCanvas::SrcRectConstraint::kStrict_SrcRectConstraint)
    .def("drawImageRect",
        py::overload_cast<const SkImage*, const SkRect&, const SkPaint*>(
            &SkCanvas::drawImageRect),
        "Draws SkImage image, scaled and translated to fill SkRect dst, using "
        "clip, SkMatrix, and optional SkPaint paint.",
        py::arg("image"), py::arg("dst"), py::arg("paint") = nullptr)
    // .def("drawImageRect",
    //     py::overload_cast<const sk_sp<SkImage>&, const SkRect&, const SkRect&,
    //         const SkPaint*, SkCanvas::SrcRectConstraint>(
    //         &SkCanvas::drawImageRect),
    //     "Draws SkRect src of SkImage image, scaled and translated to fill "
    //     "SkRect dst.",
    //     py::arg("image"), py::arg("src"), py::arg("dst"), py::arg("paint"),
    //     py::arg("constraint") =
    //         SkCanvas::SrcRectConstraint::kStrict_SrcRectConstraint)
    // .def("drawImageRect",
    //     py::overload_cast<const sk_sp<SkImage>&, const SkIRect&,
    //         const SkRect&, const SkPaint*, SkCanvas::SrcRectConstraint))
    //     &SkCanvas::drawImageRect,
    //     "Draws SkIRect isrc of SkImage image, scaled and translated to fill "
    //     "SkRect dst.",
    //     py::arg("image"), py::arg("isrc"), py::arg("dst"), py::arg("paint"),
    //     py::arg("constraint") =
    //         SkCanvas::SrcRectConstraint::kStrict_SrcRectConstraint)
    // .def("drawImageRect",
    //     py::overload_cast<const sk_sp<SkImage>&, const SkRect&,
    //         const SkPaint*>(&SkCanvas::drawImageRect),
    //     "Draws SkImage image, scaled and translated to fill SkRect dst, using "
    //     "clip, SkMatrix, and optional SkPaint paint.")
    .def("drawImageNine",
        py::overload_cast<const SkImage*, const SkIRect&, const SkRect&,
            const SkPaint*>(&SkCanvas::drawImageNine),
        "Draws SkImage image stretched proportionally to fit into SkRect dst.",
        py::arg("image"), py::arg("center"), py::arg("dst"),
        py::arg("paint") = nullptr)
    // .def("drawImageNine",
    //     py::overload_cast<const sk_sp<SkImage>&, const SkIRect&,
    //         const SkRect&, const SkPaint*>(&SkCanvas::drawImageNine),
    //     "Draws SkImage image stretched proportionally to fit into SkRect dst.")
    .def("drawBitmap", &SkCanvas::drawBitmap,
        "Draws SkBitmap bitmap, with its top-left corner at (left, top), using "
        "clip, SkMatrix, and optional SkPaint paint.",
        py::arg("bitmap"), py::arg("left"), py::arg("top"),
        py::arg("paint") = nullptr)
    .def("drawBitmapRect",
        py::overload_cast<const SkBitmap&, const SkRect&, const SkRect&,
            const SkPaint*, SkCanvas::SrcRectConstraint>(
                &SkCanvas::drawBitmapRect),
        "Draws SkRect src of SkBitmap bitmap, scaled and translated to fill "
        "SkRect dst.",
        py::arg("bitmap"), py::arg("src"), py::arg("dst"),
        py::arg("paint") = nullptr, py::arg("constraint") =
            SkCanvas::SrcRectConstraint::kStrict_SrcRectConstraint)
    .def("drawBitmapRect",
        py::overload_cast<const SkBitmap&, const SkIRect&, const SkRect&,
            const SkPaint*, SkCanvas::SrcRectConstraint>(
                &SkCanvas::drawBitmapRect),
        "Draws SkIRect isrc of SkBitmap bitmap, scaled and translated to fill "
        "SkRect dst.",
        py::arg("bitmap"), py::arg("isrc"), py::arg("dst"),
        py::arg("paint") = nullptr, py::arg("constraint") =
            SkCanvas::SrcRectConstraint::kStrict_SrcRectConstraint)
    .def("drawBitmapRect",
        py::overload_cast<const SkBitmap&, const SkRect&, const SkPaint*,
            SkCanvas::SrcRectConstraint>(&SkCanvas::drawBitmapRect),
        "Draws SkBitmap bitmap, scaled and translated to fill SkRect dst.",
        py::arg("bitmap"), py::arg("dst"), py::arg("paint") = nullptr,
        py::arg("constraint") =
            SkCanvas::SrcRectConstraint::kStrict_SrcRectConstraint)
    // .def("drawImageLattice", &SkCanvas::drawImageLattice,
    //     "Draws SkImage image stretched proportionally to fit into SkRect dst.")
    // .def("experimental_DrawEdgeAAQuad",
    //     py::overload_cast<const SkRect&, const SkPoint[4],
    //         SkCanvas::QuadAAFlags, const SkColor4f&, SkBlendMode>(
    //             &SkCanvas::experimental_DrawEdgeAAQuad),
    //     "This is an experimental API for the SkiaRenderer Chromium project, "
    //     "and its API will surely evolve if it is not removed outright.")
    // .def("experimental_DrawEdgeAAQuad",
    //     py::overload_cast<const SkRect&, const SkPoint[4],
    //         SkCanvas::QuadAAFlags, SkColor, SkBlendMode>(
    //             &SkCanvas::experimental_DrawEdgeAAQuad))
    .def("drawSimpleText",
        // &SkCanvas::drawSimpleText,
        [] (SkCanvas& canvas, const std::string& text, SkScalar x, SkScalar y,
            const SkFont& font, const SkPaint& paint) {
            canvas.drawSimpleText(
                text.c_str(), text.size(), SkTextEncoding::kUTF8, x, y, font,
                paint);
        },
        R"docstring(
        Draws text, with origin at (x, y), using clip, :py:class:`Matrix`,
        :py:class:`Font` font, and :py:class:`Paint` paint.

        This function uses the default character-to-glyph mapping from the
        :py:class:`Typeface` in font. It does not perform typeface fallback for
        characters not found in the :py:class:`Typeface`. It does not perform
        kerning or other complex shaping; glyphs are positioned based on their
        default advances.

        Text size is affected by :py:class:`Matrix` and :py:class:`Font` text
        size. Default text size is 12 point.

        All elements of paint: :py:class:`PathEffect`, :py:class:`MaskFilter`,
        :py:class:`Shader`, :py:class:`ColorFilter`, :py:class:`ImageFilter`,
        and :py:class:`DrawLooper`; apply to text. By default, draws filled
        black glyphs.

        :param str text: character code points or glyphs drawn
        :param float x: start of text on x-axis
        :param float y: start of text on y-axis
        :param skia.Font font: typeface, text size and so, used to describe the
            text
        :param skia.Paint paint: blend, color, and so on, used to draw
        )docstring",
        py::arg("text"), py::arg("x"), py::arg("y"), py::arg("font"),
        py::arg("paint"))
    .def("drawString",
        // py::overload_cast<const char[], SkScalar, SkScalar, const SkFont&,
        //     const SkPaint&>(&SkCanvas::drawString),
        [] (SkCanvas& canvas, const std::string& text, SkScalar x, SkScalar y,
            const SkFont& font, const SkPaint& paint) {
            canvas.drawString(text.c_str(), x, y, font, paint);
        },
        R"docstring(
        Draws string, with origin at (x, y), using clip, :py:class:`Matrix`,
        :py:class:`Font` font, and :py:class:`Paint` paint.

        This function uses the default character-to-glyph mapping from the
        :py:class:`Typeface` in font. It does not perform typeface fallback for
        characters not found in the :py:class:`Typeface`. It does not perform
        kerning; glyphs are positioned based on their default advances.

        String `text` is encoded as UTF-8.

        Text size is affected by :py:class:`Matrix` and font text size. Default
        text size is 12 point.

        All elements of paint: :py:class:`PathEffect`, :py:class:`MaskFilter`,
        :py:class:`Shader`, :py:class:`ColorFilter`, :py:class:`ImageFilter`,
        and :py:class:`DrawLooper`; apply to text. By default, draws filled
        black glyphs.

        :param str text: character code points drawn, ending with a char value
            of zero
        :param float x: start of string on x-axis
        :param float y: start of string on y-axis
        :param skia.Font font: typeface, text size and so, used to describe the
            text
        :param skia.Paint paint: blend, color, and so on, used to draw
        )docstring",
        py::arg("text"), py::arg("x"), py::arg("y"), py::arg("font"),
        py::arg("paint"))
    // .def("drawString",
    //     py::overload_cast<const SkString&, SkScalar, SkScalar, const SkFont&,
    //         const SkPaint&>(&SkCanvas::drawString),
    //     "DDraws SkString, with origin at (x, y), using clip, SkMatrix, SkFont "
    //     "font, and SkPaint paint.")
    .def("drawTextBlob",
        py::overload_cast<const SkTextBlob*, SkScalar, SkScalar,
            const SkPaint&>(&SkCanvas::drawTextBlob),
        R"docstring(
        Draws :py:class:`TextBlob` blob at (x, y), using clip,
        :py:class:`Matrix`, and :py:class:`Paint` paint.

        `blob` contains glyphs, their positions, and paint attributes specific
        to text: :py:class:`Typeface`, :py:class:`Paint` text size,
        :py:class:`Paint` text scale x, :py:class:`Paint` text skew x,
        :py:class:`Paint`::Align, :py:class:`Paint`::Hinting, anti-alias,
        :py:class:`Paint` fake bold, :py:class:`Paint` font embedded bitmaps,
        :py:class:`Paint` full hinting spacing, LCD text, :py:class:`Paint`
        linear text, and :py:class:`Paint` subpixel text.

        :py:class:`TextEncoding` must be set to
        :py:attr:`TextEncoding.kGlyphID`.

        Elements of paint: anti-alias, :py:class:`BlendMode`, color including
        alpha, :py:class:`ColorFilter`, :py:class:`Paint` dither,
        :py:class:`DrawLooper`, :py:class:`MaskFilter`, :py:class:`PathEffect`,
        :py:class:`Shader`, and :py:class:`Paint.Style`; apply to blob. If
        :py:class:`Paint` contains :py:attr:`Paint.kStroke`: :py:class:`Paint`
        iter limit, :py:class:`Paint.Cap`, :py:class:`Paint.Join`, and
        :py:class:`Paint` stroke width; apply to :py:class:`Path` created from
        blob.

        :param skia.TextBlob blob: glyphs, positions, and their paints' text
            size, typeface, and so on
        :param float x: horizontal offset applied to blob
        :param float y: vertical offset applied to blob
        :param skia.Paint paint: blend, color, stroking, and so on, used to draw
        )docstring",
        py::arg("blob"), py::arg("x"), py::arg("y"), py::arg("paint"))
    // .def("drawTextBlob",
    //     py::overload_cast<const sk_sp<SkTextBlob>&, SkScalar, SkScalar,
    //         const SkPaint&>(&SkCanvas::drawTextBlob),
    //     "Draws SkTextBlob blob at (x, y), using clip, SkMatrix, and SkPaint "
    //     "paint.")
    // .def("drawPicture",
    //     py::overload_cast<const SkPicture*>(&SkCanvas::drawPicture))
    // .def("drawPicture",
    //     py::overload_cast<const sk_sp<SkPicture>&>(&SkCanvas::drawPicture),
    //     "Draws SkPicture picture, using clip and SkMatrix.")
    .def("drawPicture",
        py::overload_cast<const SkPicture*, const SkMatrix*, const SkPaint*>(
            &SkCanvas::drawPicture),
        R"docstring(
        Draws :py:class:`Picture` picture, using clip and :py:class:`Matrix`;
        transforming picture with :py:class:`Matrix` matrix, if provided; and
        use :py:class:`Paint` paint alpha, :py:class:`ColorFilter`,
        :py:class:`ImageFilter`, and :py:class:`BlendMode`, if provided.

        :py:class:`Picture` records a series of draw commands for later
        playback.

        matrix transformation is equivalent to: save(), concat(), drawPicture(),
        restore(). paint use is equivalent to: saveLayer(), drawPicture(),
        restore().

        :param skia.Picture picture: recorded drawing commands to play
        :param skia.Matrix matrix:  :py:class:`Matrix` to rotate, scale,
            translate, and so on; may be `None`
        :param skia.Paint paint: :py:class:`Paint` to apply transparency,
            filtering, and so on; may be `None`
        )docstring",
        py::arg("picture"), py::arg("matrix") = nullptr,
        py::arg("paint") = nullptr)
    // .def("drawPicture",
    //     py::overload_cast<const sk_sp<SkPicture>&, const SkMatrix*,
    //         const SkPaint*>(&SkCanvas::drawPicture),
    //     "Draws SkPicture picture, using clip and SkMatrix; transforming "
    //     "picture with SkMatrix matrix, if provided; and use SkPaint paint "
    //     "alpha, SkColorFilter, SkImageFilter, and SkBlendMode, if provided.")
    .def("drawVertices",
        // py::overload_cast<const SkVertices*, SkBlendMode, const SkPaint&>(
        //     &SkCanvas::drawVertices),
        [] (SkCanvas& canvas, const SkVertices* vertices, const SkPaint& paint,
            SkBlendMode mode) { canvas.drawVertices(vertices, mode, paint); },
        R"docstring(
        Draws :py:class:`Vertices` vertices, a triangle mesh, using clip and
        :py:class:`Matrix`.

        If vertices texs and vertices colors are defined in vertices, and
        :py:class:`Paint` paint contains :py:class:`Shader`,
        :py:class:`BlendMode` mode combines vertices colors with
        :py:class:`Shader`.

        :param skia.Vertices vertices: triangle mesh to draw
        :param skia.BlendMode mode: combines vertices colors with
            :py:class:`Shader`, if both are present
        :param skia.Paint paint: specifies the :py:class:`Shader`, used as
            :py:class:`Vertices` texture
        )docstring",
        py::arg("vertices"), py::arg("paint"),
        py::arg("mode") = SkBlendMode::kModulate)
    // .def("drawVertices",
    //     py::overload_cast<const SkVertices*, const SkPaint&>(
    //         &SkCanvas::drawVertices),
    //     "Variant of 3-parameter drawVertices, using the default of Modulate "
    //     "for the blend parameter.")
    // .def("drawVertices",
    //     py::overload_cast<const sk_sp<SkVertices>&, SkBlendMode,
    //         const SkPaint&>(&SkCanvas::drawVertices),
    //     "Draws SkVertices vertices, a triangle mesh, using clip and SkMatrix.")
    // .def("drawVertices",
    //     py::overload_cast<const sk_sp<SkVertices>&, const SkPaint&>(
    //         &SkCanvas::drawVertices),
    //     "Variant of 3-parameter drawVertices, using the default of Modulate "
    //     "for the blend parameter.")
    .def("drawPatch",
        // py::overload_cast<const SkPoint[12], const SkColor[4],
        //     const SkPoint[4], SkBlendMode, const SkPaint&>(
        //         &SkCanvas::drawPatch),
        [] (SkCanvas& canvas, const std::vector<SkPoint>& cubics,
            const std::vector<SkColor>& colors,
            const std::vector<SkPoint>& texCoords,
            SkBlendMode mode, const SkPaint& paint) {
            if (cubics.size() != 12)
                throw std::runtime_error("cubics must have 12 elements");
            if (colors.size() != 4)
                throw std::runtime_error("colors must have 4 elements");
            if (!(texCoords.size() == 4 || texCoords.empty()))
                throw std::runtime_error("texCoords must have 0 or 4 elements");

            canvas.drawPatch(
                &cubics[0], &colors[0],
                (texCoords.empty()) ? nullptr : &texCoords[0], mode, paint);
        },
        R"docstring(
        Draws a Coons patch: the interpolation of four cubics with shared
        corners, associating a color, and optionally a texture
        :py:class:`Point`, with each corner.

        Coons patch uses clip and :py:class:`Matrix`, paint :py:class:`Shader`,
        :py:class:`ColorFilter`, alpha, :py:class:`ImageFilter`, and
        :py:class:`BlendMode`. If :py:class:`Shader` is provided it is treated
        as Coons patch texture; :py:class:`BlendMode` mode combines color colors
        and :py:class:`Shader` if both are provided.

        :py:class:`Point` array cubics specifies four :py:class:`Path` cubic
        starting at the top-left corner, in clockwise order, sharing every
        fourth point. The last :py:class:`Path` cubic ends at the first point.

        Color array color associates colors with corners in top-left, top-right,
        bottom-right, bottom-left order.

        If paint contains :py:class:`Shader`, :py:class:`Point` array texCoords
        maps :py:class:`Shader` as texture to corners in top-left, top-right,
        bottom-right, bottom-left order.

        :param List[skia.Point] cubics: :py:class:`Path` cubic array, sharing
            common points (length 12)
        :param List[int] colors: color array, one for each corner (length 4)
        :param List[skia.Point] texCoords: :py:class:`Point` array of texture
            coordinates, mapping :py:class:`Shader` to corners (length 4); may
            be an empty list
        :param mode: :py:class:`BlendMode` for colors, and for
            :py:class:`Shader` if paint has one
        :param paint: :py:class:`Shader`, :py:class:`ColorFilter`,
            :py:class:`BlendMode`, used to draw
        )docstring",
        py::arg("cubics"), py::arg("colors"), py::arg("texCoords"),
        py::arg("mode"), py::arg("paint"))
    // .def("drawPatch",
    //     py::overload_cast<const SkPoint[12], const SkColor[4],
    //         const SkPoint[4], const SkPaint&>(
    //             &SkCanvas::drawPatch),
    //     "Draws SkPath cubic Coons patch: the interpolation of four cubics with "
    //     "shared corners, associating a color, and optionally a texture "
    //     "SkPoint, with each corner.")
    .def("drawAtlas",
        // py::overload_cast<const SkImage*, const SkRSXform[], const SkRect[],
        //     const SkColor[], int, SkBlendMode, const SkRect*, const SkPaint*>(
        //         &SkCanvas::drawAtlas),
        [] (SkCanvas& canvas, const SkImage* atlas,
            const std::vector<SkRSXform>& xform,
            const std::vector<SkRect>& tex,
            const std::vector<SkColor>& colors,
            SkBlendMode mode, const SkRect* cullRect, const SkPaint* paint) {
            if (xform.size() != tex.size())
                throw std::runtime_error(
                    "xform and tex must have the same length.");
            if (!colors.empty() && colors.size() != xform.size())
                throw std::runtime_error(
                    "colors must have the same length with xform.");
            canvas.drawAtlas(atlas, &xform[0], &tex[0],
                (colors.empty()) ? nullptr : &colors[0],
                xform.size(), mode, cullRect, paint);
        },
        R"docstring(
        Draws a set of sprites from atlas, using clip, :py:class:`Matrix`, and
        optional :py:class:`Paint` paint.

        paint uses anti-alias, alpha, :py:class:`ColorFilter`,
        :py:class:`ImageFilter`, and :py:class:`BlendMode` to draw, if present.
        For each entry in the array, :py:class:`Rect` tex locates sprite in
        atlas, and :py:class:`RSXform` xform transforms it into destination
        space.

        xform, text, and colors if present, must contain count entries. Optional
        colors are applied for each sprite using :py:class:`BlendMode` mode,
        treating sprite as source and colors as destination. Optional cullRect
        is a conservative bounds of all transformed sprites. If cullRect is
        outside of clip, canvas can skip drawing.

        If atlas is `None`, this draws nothing.

        :param skia.Image atlas: :py:class:`Image` containing sprites
        :param List[skia.RSXform xform]: :py:class:`RSXform` mappings for
            sprites in atlas
        :param List[skia.Rect] tex: :py:class:`Rect` locations of sprites in
            atlas
        :param List[int] colors: one per sprite, blended with sprite using
            :py:class:`BlendMode`; may be `None`
        :param skia.BlendMode mode: :py:class:`BlendMode` combining colors and
            sprites
        :param Union[skia.Rect,NoneType] cullRect: bounds of transformed sprites
            for efficient clipping; may be `None`
        :param Union[skia.Paint,NoneType] paint: :py:class:`ColorFilter`,
            :py:class:`ImageFilter`, :py:class:`BlendMode`, and so on; may be
            `None`
        )docstring",
        py::arg("atlas"), py::arg("xform"), py::arg("tex"), py::arg("colors"),
        py::arg("mode"), py::arg("cullRect") = nullptr,
        py::arg("paint") = nullptr)
    // .def("drawAtlas",
    //     py::overload_cast<const sk_sp<SkImage>&, const SkRSXform[],
    //         const SkRect[], const SkColor[], int, SkBlendMode, const SkRect*,
    //         const SkPaint*>(&SkCanvas::drawAtlas),
    //     "Draws a set of sprites from atlas, using clip, SkMatrix, and optional "
    //     "SkPaint paint.")
    // .def("drawAtlas",
    //     py::overload_cast<const SkImage*, const SkRSXform[], const SkRect[],
    //         int, const SkRect*, const SkPaint*>(
    //             &SkCanvas::drawAtlas),
    //     "Draws a set of sprites from atlas, using clip, SkMatrix, and optional "
    //     "SkPaint paint.")
    // .def("drawAtlas",
    //     py::overload_cast<const sk_sp<SkImage>&, const SkRSXform[],
    //         const SkRect[], int, const SkRect*, const SkPaint*>(
    //             &SkCanvas::drawAtlas),
    //     "Draws a set of sprites from atlas, using clip, SkMatrix, and optional "
    //     "SkPaint paint.")
    // .def("drawDrawable",
    //     py::overload_cast<SkDrawable*, const SkMatrix*>(
    //         &SkCanvas::drawDrawable),
    //     "Draws SkDrawable drawable using clip and SkMatrix, concatenated with "
    //     "optional matrix.")
    // .def("drawDrawable",
    //     py::overload_cast<SkDrawable*, SkScalar, SkScalar>(
    //         &SkCanvas::drawDrawable),
    //     "Draws SkDrawable drawable using clip and SkMatrix, offset by (x, y).")
    // .def("drawAnnotation",
    //     py::overload_cast<const SkRect&, const char[], SkData*>(
    //         &SkCanvas::drawAnnotation),
    //     "Associates SkRect on SkCanvas with an annotation; a key-value pair, "
    //     "where the key is a null-terminated UTF-8 string, and optional value "
    //     "is stored as SkData.")
    .def("drawAnnotation",
        // py::overload_cast<const SkRect&, const char[], const sk_sp<SkData>&>(
        //     &SkCanvas::drawAnnotation),
        [] (SkCanvas& canvas, const SkRect& rect, const std::string& key,
            const sk_sp<SkData>& value) {
            canvas.drawAnnotation(rect, key.c_str(), value);
        },
        R"docstring(
        Associates :py:class:`Rect` on :py:class:`Canvas` when an annotation; a
        key-value pair, where the key is a null-terminated UTF-8 string, and
        optional value is stored as :py:class:`Data`.

        Only some canvas implementations, such as recording to
        :py:class:`Picture`, or drawing to document PDF, use annotations.

        :param skia.Rect rect: :py:class:`Rect` extent of canvas to annotate
        :param str key: string used for lookup
        :param skia.Data value: data holding value stored in annotation
        )docstring",
        py::arg("rect"), py::arg("key"), py::arg("value"))
    .def("isClipEmpty", &SkCanvas::isClipEmpty,
        "Returns true if clip is empty; that is, nothing will draw.")
    .def("isClipRect", &SkCanvas::isClipRect,
        "Returns true if clip is SkRect and not empty.")
    .def("getTotalMatrix", &SkCanvas::getTotalMatrix, "Returns SkMatrix.")
    .def("getLocalToDevice",
        py::overload_cast<>(&SkCanvas::getLocalToDevice, py::const_))
    // .def("getLocalToDevice",
    //     py::overload_cast<SkScalar[16]>(
    //         &SkCanvas::getLocalToDevice, py::const_))
    // .def("experimental_getLocalToWorld",
    //     py::overload_cast<>(
    //         &SkCanvas::experimental_getLocalToWorld, py::const_))
    // .def("experimental_getLocalToCamera",
    //     py::overload_cast<>(
    //         &SkCanvas::experimental_getLocalToCamera, py::const_))
    // .def("experimental_getLocalToCamera",
    //     py::overload_cast<SkScalar[16]>(
    //         &SkCanvas::experimental_getLocalToCamera, py::const_))
    // .def("experimental_getLocalToWorld",
    //     py::overload_cast<SkScalar[16]>(
    //         &SkCanvas::experimental_getLocalToWorld, py::const_))
    // Static methods.
    .def_static("MakeRasterDirect",
        // &SkCanvas::MakeRasterDirect,
        [](const SkImageInfo& image_info, py::buffer pixels, size_t rowBytes,
            const SkSurfaceProps* surfaceProps) {
            py::buffer_info info = pixels.request();
            size_t given_size = (info.ndim > 0) ?
                info.shape[0] * info.strides[0] : 0;
            rowBytes = (rowBytes == 0) ? image_info.minRowBytes() : rowBytes;
            auto required = rowBytes * image_info.height();
            if (given_size < required)
                throw std::runtime_error("Buffer is smaller than required");
            auto canvas = SkCanvas::MakeRasterDirect(
                image_info, info.ptr, rowBytes, surfaceProps);
            if (!canvas)
                throw std::runtime_error("Failed to create Canvas");
            return canvas;
        },
        R"docstring(
        Allocates raster :py:class:`Canvas` that will draw directly into pixels.

        :py:class:`Canvas` is returned if all parameters are valid. Valid
        parameters include: info dimensions are zero or positive; info contains
        :py:class:`ColorType` and :py:class:`AlphaType` supported by raster
        surface; pixels is buffer object of sufficient length; rowBytes is zero
        or large enough to contain info width pixels of :py:class:`ColorType`.

        Pass zero for rowBytes to compute rowBytes from info width and size of
        pixel. If rowBytes is greater than zero, it must be equal to or greater
        than info width times bytes required for :py:class:`ColorType`.

        Pixel buffer size should be info height times computed rowBytes. Pixels
        are not initialized. To access pixels after drawing, call flush() or
        peekPixels().

        :param skia.ImageInfo info: width, height, :py:class:`ColorType`,
            :py:class:`AlphaType`, :py:class:`ColorSpace`, of raster surface;
            width, or height, or both, may be zero
        :param Union[bytes,bytearray,memoryview] pixels: destination pixels
            buffer
        :param int rowBytes: interval from one :py:class:`Surface` row to the
            next, or zero
        :param skia.SurfaceProps props: LCD striping orientation and setting for
            device independent fonts; may be `None`
        )docstring",
        py::arg("image_info"), py::arg("pixels"), py::arg("rowBytes") = 0,
        py::arg("surfaceProps") = nullptr)
    .def_static("MakeRasterDirectN32",
        // &SkCanvas::MakeRasterDirectN32,
        [](int width, int height, py::buffer pixels, size_t rowBytes) {
            py::buffer_info info = pixels.request();
            if (width < 0 || height < 0)
                throw std::runtime_error(
                    "width and height must be greater than 0");
            rowBytes = (rowBytes == 0) ? width * sizeof(SkPMColor) : rowBytes;
            size_t given_size = (info.ndim > 0) ?
                info.shape[0] * info.strides[0] : 0;
            auto required = rowBytes * height;
            if (given_size < required)
                throw std::runtime_error("Buffer is smaller than required");
            auto canvas = SkCanvas::MakeRasterDirectN32(
                width, height, static_cast<SkPMColor*>(info.ptr), rowBytes);
            if (!canvas)
                throw std::runtime_error("Failed to create Canvas");
            return canvas;
        },
        R"docstring(
        Allocates raster :py:class:`Canvas` specified by inline image
        specification.

        Subsequent :py:class:`Canvas` calls draw into pixels.
        :py:class:`ColorType` is set to :py:attr:`ColorType.kN32`.
        :py:class:`AlphaType` is set to :py:attr:`AlphaType.kPremul`. To access
        pixels after drawing, call flush() or peekPixels().

        :py:class:`Canvas` is returned if all parameters are valid. Valid
        parameters include: width and height are zero or positive; pixels is
        buffer object with sufficient length; rowBytes is zero or large enough
        to contain width pixels of :py:attr:`ColorType.kN32`.

        Pass zero for rowBytes to compute rowBytes from width and size of pixel.
        If rowBytes is greater than zero, it must be equal to or greater than
        width times bytes required for :py:class:`ColorType`.

        Pixel buffer size should be height times rowBytes.

        :param int width: pixel column count on raster surface created; must be
            zero or greater
        :param int height: pixel row count on raster surface created; must be
            zero or greater
        :param Union[bytes,bytearray,memoryview] pixels: pointer to destination
            pixels buffer; buffer size should be height times rowBytes
        :param int rowBytes: interval from one :py:class:`Surface` row to the
            next, or zero
        )docstring",
        py::arg("width"), py::arg("height"), py::arg("pixels"),
        py::arg("rowBytes") = 0)
    ;

    m.def("MakeNullCanvas", &SkMakeNullCanvas);
}
