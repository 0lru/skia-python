#include "common.h"
#include <pybind11/numpy.h>

template<typename T>
using NumPy = py::array_t<T, py::array::c_style | py::array::forcecast>;

void initCanvas(py::module &m) {
py::class_<SkAutoCanvasRestore>(m, "AutoCanvasRestore", R"docstring(
    Stack helper class calls SkCanvas::restoreToCount when SkAutoCanvasRestore
    goes out of scope.

    Use this to guarantee that the canvas is restored to a known state.
    )docstring")
    .def(py::init<SkCanvas*, bool>(), "Preserves SkCanvas::save() count.")
    .def("restore", &SkAutoCanvasRestore::restore,
        "Restores SkCanvas to saved state immediately.")
    ;

py::enum_<SkClipOp>(m, "ClipOp")
    .value("kDifference", SkClipOp::kDifference)
    .value("kIntersect", SkClipOp::kIntersect)
    .value("kExtraEnumNeedInternallyPleaseIgnoreWillGoAway2",
        SkClipOp::kExtraEnumNeedInternallyPleaseIgnoreWillGoAway2)
    .value("kExtraEnumNeedInternallyPleaseIgnoreWillGoAway3",
        SkClipOp::kExtraEnumNeedInternallyPleaseIgnoreWillGoAway3)
    .value("kExtraEnumNeedInternallyPleaseIgnoreWillGoAway4",
        SkClipOp::kExtraEnumNeedInternallyPleaseIgnoreWillGoAway4)
    .value("kExtraEnumNeedInternallyPleaseIgnoreWillGoAway5",
        SkClipOp::kExtraEnumNeedInternallyPleaseIgnoreWillGoAway5)
    .value("kMax_EnumValue", SkClipOp::kMax_EnumValue)
    .export_values();

py::class_<SkCanvas> canvas(m, "Canvas", R"docstring(
    :py:class:`Canvas` provides an interface for drawing, and how the drawing is
    clipped and transformed.

    :py:class:`Canvas` contains a stack of :py:class:`Matrix` and clip values.

    :py:class:`Canvas` and :py:class:`Paint` together provide the state to draw
    into :py:class:`Surface` or SkBaseDevice. Each :py:class:`Canvas` draw call
    transforms the geometry of the object by the concatenation of all
    :py:class:`Matrix` values in the stack. The transformed geometry is clipped
    by the intersection of all of clip values in the stack. The
    :py:class:`Canvas` draw calls use :py:class:`Paint` to supply drawing state
    such as color, :py:class:`Typeface`, text size, stroke width,
    :py:class:`Shader` and so on.

    To draw to a pixel-based destination, create raster surface or GPU surface.
    Request :py:class:`Canvas` from :py:class:`Surface` to obtain the interface
    to draw. :py:class:`Canvas` generated by raster surface draws to memory
    visible to the CPU. :py:class:`Canvas` generated by GPU surface uses Vulkan
    or OpenGL to draw to the GPU.

    To draw to a document, obtain :py:class:`Canvas` from SVG canvas, document
    PDF, or :py:class:`PictureRecorder`. SkDocument based :py:class:`Canvas`
    and other :py:class:`Canvas` subclasses reference SkBaseDevice describing
    the destination.

    :py:class:`Canvas` can be constructed to draw to :py:class:`Bitmap` without
    first creating raster surface. This approach may be deprecated in the
    future.

    .. rubric:: Classes

    .. autosummary::
        :nosignatures:

        Canvas.SrcRectConstraint
        Canvas.PointMode
        Canvas.QuadAAFlags
        Canvas.SaveLayerRec
        Canvas.Lattice

    )docstring");

py::enum_<SkCanvas::SrcRectConstraint>(canvas, "SrcRectConstraint")
    .value("kStrict", SkCanvas::SrcRectConstraint::kStrict_SrcRectConstraint)
    .value("kFast", SkCanvas::SrcRectConstraint::kFast_SrcRectConstraint)
    .export_values();

py::enum_<SkCanvas::PointMode>(canvas, "PointMode")
    .value("kPoints", SkCanvas::PointMode::kPoints_PointMode)
    .value("kLines", SkCanvas::PointMode::kLines_PointMode)
    .value("kPolygon", SkCanvas::PointMode::kPolygon_PointMode)
    .export_values();

py::enum_<SkCanvas::QuadAAFlags>(canvas, "QuadAAFlags")
    .value("kLeft", SkCanvas::QuadAAFlags::kLeft_QuadAAFlag)
    .value("kTop", SkCanvas::QuadAAFlags::kTop_QuadAAFlag)
    .value("kRight", SkCanvas::QuadAAFlags::kRight_QuadAAFlag)
    .value("kBottom", SkCanvas::QuadAAFlags::kBottom_QuadAAFlag)
    .value("kNone", SkCanvas::QuadAAFlags::kNone_QuadAAFlags)
    .value("kAll", SkCanvas::QuadAAFlags::kAll_QuadAAFlags)
    .export_values();

py::class_<SkCanvas::SaveLayerRec> savelayerrec(canvas, "SaveLayerRec",
    R"docstring(
    SaveLayerRec contains the state used to create the layer.
    )docstring");

savelayerrec
    .def(py::init(),
        "Sets fBounds, fPaint, and fBackdrop to nullptr.")
    .def(py::init<const SkRect*, const SkPaint*, SkCanvas::SaveLayerFlags>(),
        "Sets fBounds, fPaint, and fSaveLayerFlags; sets fBackdrop to nullptr.")
    .def(py::init<const SkRect*, const SkPaint*, const SkImageFilter*,
        SkCanvas::SaveLayerFlags>(),
        "Sets fBounds, fPaint, fBackdrop, and fSaveLayerFlags.")
    .def(py::init<const SkRect*, const SkPaint*, const SkImageFilter*,
        const SkImage*, const SkMatrix*, SkCanvas::SaveLayerFlags>(),
        "Experimental.")
    .def_readwrite("fBounds", &SkCanvas::SaveLayerRec::fBounds,
        "hints at layer size limit",
        py::return_value_policy::reference)
    .def_readwrite("fPaint", &SkCanvas::SaveLayerRec::fPaint,
        "modifies overlay",
        py::return_value_policy::reference)
    .def_readwrite("fBackdrop", &SkCanvas::SaveLayerRec::fBackdrop,
        "If not null, this triggers the same initialization behavior as "
        "setting kInitWithPrevious_SaveLayerFlag on fSaveLayerFlags: the "
        "current layer is copied into the new layer, rather than initializing "
        "the new layer with transparent-black.",
        py::return_value_policy::reference)
    .def_readwrite("fClipMask", &SkCanvas::SaveLayerRec::fClipMask,
        "clips layer with mask alpha",
        py::return_value_policy::reference)
    .def_readwrite("fClipMatrix", &SkCanvas::SaveLayerRec::fClipMatrix,
        "transforms mask alpha used to clip",
        py::return_value_policy::reference)
    .def_readwrite("fSaveLayerFlags", &SkCanvas::SaveLayerRec::fSaveLayerFlags,
        "preserves LCD text, creates with prior layer contents")
    ;

py::class_<SkCanvas::Lattice> lattice(canvas, "Lattice", R"docstring(
    SkCanvas::Lattice divides SkBitmap or SkImage into a rectangular grid.

    Grid entries on even columns and even rows are fixed; these entries are
    always drawn at their original size if the destination is large enough. If
    the destination side is too small to hold the fixed entries, all fixed
    entries are proportionately scaled down to fit. The grid entries not on even
    columns and rows are scaled to fit the remaining space, if any.
    )docstring");

lattice
    .def_readwrite("fXDivs", &SkCanvas::Lattice::fXDivs)
    .def_readwrite("fYDivs", &SkCanvas::Lattice::fYDivs)
    .def_readwrite("fRectTypes", &SkCanvas::Lattice::fRectTypes)
    .def_readwrite("fXCount", &SkCanvas::Lattice::fXCount)
    .def_readwrite("fYCount", &SkCanvas::Lattice::fYCount)
    .def_readwrite("fBounds", &SkCanvas::Lattice::fBounds)
    .def_readwrite("fColors", &SkCanvas::Lattice::fColors)
    ;

py::enum_<SkCanvas::Lattice::RectType>(lattice, "RectType")
    .value("kDefault", SkCanvas::Lattice::RectType::kDefault)
    .value("kTransparent", SkCanvas::Lattice::RectType::kTransparent)
    .value("kFixedColor", SkCanvas::Lattice::RectType::kFixedColor)
    .export_values();

canvas.def(py::init<>(),
        R"docstring(
        Creates an empty :py:class:`Canvas` with no backing device or pixels,
        with a width and height of zero.
        )docstring")
    .def(py::init<int, int, const SkSurfaceProps*>(),
        R"docstring(
        Creates :py:class:`Canvas` of the specified dimensions without a
        :py:class:`Surface`.

        Used by subclasses with custom implementations for draw member
        functions.

        If props equals `None`, :py:class:`SurfaceProps` are created with
        :py:class:`SurfaceProps.InitType` settings, which choose the pixel
        striping direction and order. Since a platform may dynamically change
        its direction when the device is rotated, and since a platform may have
        multiple monitors with different characteristics, it is best not to rely
        on this legacy behavior.

        :width: zero or greater
        :height: zero or greater
        :props: LCD striping orientation and setting for device independent
            fonts; may be `None`
        )docstring",
        py::arg("width"), py::arg("height"), py::arg("props") = nullptr)
    .def(py::init<const SkBitmap&>(),
        R"docstring(
        Constructs a canvas that draws into bitmap.

        Sets :py:attr:`SurfaceProps.kLegacyFontHost` in constructed
        :py:class:`Surface`.

        :py:class:`Bitmap` is copied so that subsequently editing bitmap will
        not affect constructed :py:class:`Canvas`.

        May be deprecated in the future.

        :bitmap: width, height, :py:class:`ColorType`, :py:class:`AlphaType`,
            and pixel storage of raster surface
        )docstring",
        py::arg("bitmap"))
    .def(py::init<const SkBitmap&, const SkSurfaceProps&>(),
        R"docstring(
        Constructs a canvas that draws into bitmap.

        Use props to match the device characteristics, like LCD striping.

        bitmap is copied so that subsequently editing bitmap will not affect
        constructed :py:class:`Canvas`.

        :bitmap: width, height, :py:class:`ColorType`, :py:class:`AlphaType`,
            and pixel storage of raster surface
        :props: order and orientation of RGB striping; and whether to use device
            independent fonts
        )docstring",
        py::arg("bitmap"), py::arg("props"))
    .def("imageInfo", &SkCanvas::imageInfo, "Returns SkImageInfo for SkCanvas.")
    .def("getProps", &SkCanvas::getProps,
        "Copies SkSurfaceProps, if SkCanvas is associated with raster surface "
        "or GPU surface, and returns true.")
    .def("flush", &SkCanvas::flush,
        "Triggers the immediate execution of all pending draw operations.")
    .def("getBaseLayerSize", &SkCanvas::getBaseLayerSize,
        "Gets the size of the base or root layer in global canvas coordinates.")
    .def("makeSurface", &SkCanvas::makeSurface,
        "Creates SkSurface matching info and props, and associates it with "
        "SkCanvas.",
        py::arg("info"), py::arg("props") = nullptr)
    .def("getGrContext", &SkCanvas::getGrContext,
        "Returns GPU context of the GPU surface associated with SkCanvas.",
        py::return_value_policy::reference)
    .def("getSurface", &SkCanvas::getSurface,
        "Sometimes a canvas is owned by a surface.",
        py::return_value_policy::reference)
    // .def("accessTopLayerPixels", &SkCanvas::accessTopLayerPixels,
    //     "Returns the pixel base address, SkImageInfo, rowBytes, and origin if "
    //     "the pixels can be read directly.",
    //     py::return_value_policy::reference)
    // .def("accessTopRasterHandle", &SkCanvas::accessTopRasterHandle,
    //     "Returns custom context that tracks the SkMatrix and clip.")
    .def("peekPixels", &SkCanvas::peekPixels,
        "Returns true if SkCanvas has direct access to its pixels.")
    .def("readPixels",
        // py::overload_cast<const SkImageInfo&, void*, size_t, int, int>(
        //     &SkCanvas::readPixels),
        [] (SkCanvas& canvas, NumPy<uint8_t> array, int srcX, int srcY) {
            py::buffer_info info = array.request();
            if (info.ndim <= 1)
                throw std::runtime_error(
                    "Number of dimensions must be 2 or more.");
            if (info.shape[0] == 0 || info.shape[1] == 0)
                throw std::runtime_error(
                    "Width and height must be greater than 0.");
            auto imageinfo = SkImageInfo::MakeN32Premul(
                info.shape[1], info.shape[0]);
            return canvas.readPixels(
                imageinfo, info.ptr, info.strides[0], srcX, srcY);
        },
        "Copies SkRect of pixels from SkCanvas into dstPixels.",
        py::arg("array"), py::arg("srcX") = 0, py::arg("srcY") = 0)
    .def("readPixels",
        py::overload_cast<const SkPixmap&, int, int>(&SkCanvas::readPixels),
        "Copies SkRect of pixels from SkCanvas into pixmap.")
    .def("readPixels",
        py::overload_cast<const SkBitmap&, int, int>(&SkCanvas::readPixels),
        "Copies SkRect of pixels from SkCanvas into bitmap.")
    .def("writePixels",
        // py::overload_cast<const SkImageInfo&, const void*, size_t, int, int>(
        //     &SkCanvas::writePixels),
        [] (SkCanvas& canvas, NumPy<uint8_t> array, int x, int y) {
            py::buffer_info info = array.request();
            if (info.ndim <= 1)
                throw std::runtime_error(
                    "Number of dimensions must be 2 or more.");
            if (info.shape[0] == 0 || info.shape[1] == 0)
                throw std::runtime_error(
                    "Width and height must be greater than 0.");
            auto imageinfo = SkImageInfo::MakeN32Premul(
                info.shape[1], info.shape[0]);
            return canvas.writePixels(
                imageinfo, info.ptr, info.strides[0], x, y);
        },
        "Copies SkRect from pixels to SkCanvas.",
        py::arg("array"), py::arg("x") = 0, py::arg("y") = 0)
    .def("writePixels",
        py::overload_cast<const SkBitmap&, int, int>(&SkCanvas::writePixels),
        "Copies SkRect from pixels to SkCanvas.")
    .def("save", &SkCanvas::save, "Saves SkMatrix and clip.")
    .def("saveLayer",
        py::overload_cast<const SkRect*, const SkPaint*>(&SkCanvas::saveLayer),
        "Saves SkMatrix and clip, and allocates a SkBitmap for subsequent "
        "drawing.")
    .def("saveLayer",
        py::overload_cast<const SkRect&, const SkPaint*>(&SkCanvas::saveLayer),
        "Saves SkMatrix and clip, and allocates a SkBitmap for subsequent "
        "drawing.")
    .def("saveLayerAlpha", &SkCanvas::saveLayerAlpha,
        "Saves SkMatrix and clip, and allocates SkBitmap for subsequent "
        "drawing.")
    .def("saveLayer",
        py::overload_cast<const SkCanvas::SaveLayerRec&>(&SkCanvas::saveLayer),
        "Saves SkMatrix and clip, and allocates a SkBitmap for subsequent "
        "drawing.")
    .def("experimental_saveCamera",
        py::overload_cast<const SkM44&, const SkM44&>(
            &SkCanvas::experimental_saveCamera))
    .def("experimental_saveCamera",
        py::overload_cast<const SkScalar[16], const SkScalar[16]>(
            &SkCanvas::experimental_saveCamera))
    .def("restore", &SkCanvas::restore,
        "Removes changes to SkMatrix and clip since SkCanvas state was last "
        "saved.")
    .def("getSaveCount", &SkCanvas::getSaveCount,
        "Returns the number of saved states, each containing: SkMatrix and "
        "clip.")
    .def("restoreToCount", &SkCanvas::restoreToCount,
        "Restores state to SkMatrix and clip values when save(), saveLayer(), "
        "saveLayerPreserveLCDTextRequests(), or saveLayerAlpha() returned "
        "saveCount.")
    .def("translate", &SkCanvas::translate,
        "Translates SkMatrix by dx along the x-axis and dy along the y-axis.")
    .def("scale", &SkCanvas::scale,
        "Scales SkMatrix by sx on the x-axis and sy on the y-axis.")
    .def("rotate", py::overload_cast<SkScalar>(&SkCanvas::rotate),
        "Rotates SkMatrix by degrees.")
    .def("rotate",
        py::overload_cast<SkScalar, SkScalar, SkScalar>(&SkCanvas::rotate),
        "Rotates SkMatrix by degrees about a point at (px, py).")
    .def("skew", &SkCanvas::skew,
        "Skews SkMatrix by sx on the x-axis and sy on the y-axis.")
    .def("concat", &SkCanvas::concat,
        "Replaces SkMatrix with matrix premultiplied with existing SkMatrix.")
    .def("concat44", py::overload_cast<const SkM44&>(&SkCanvas::concat44))
    .def("concat44", py::overload_cast<const SkScalar[]>(&SkCanvas::concat44))
    .def("setMatrix", &SkCanvas::setMatrix, "Replaces SkMatrix with matrix.")
    .def("resetMatrix", &SkCanvas::resetMatrix,
        "Sets SkMatrix to the identity matrix.")
    .def("clipRect",
        py::overload_cast<const SkRect&, SkClipOp, bool>(&SkCanvas::clipRect),
        "Replaces clip with the intersection or difference of clip and rect, "
        "with an aliased or anti-aliased clip edge.")
    .def("clipRect",
        py::overload_cast<const SkRect&, SkClipOp>(&SkCanvas::clipRect),
        "Replaces clip with the intersection or difference of clip and rect.")
    .def("clipRect",
        py::overload_cast<const SkRect&, bool>(&SkCanvas::clipRect),
        "Replaces clip with the intersection of clip and rect.",
        py::arg("rect"), py::arg("doAntiAlias") = false)
    .def("androidFramework_setDeviceClipRestriction",
        &SkCanvas::androidFramework_setDeviceClipRestriction,
        "Sets the maximum clip rectangle, which can be set by clipRect(), "
        "clipRRect() and clipPath() and intersect the current clip with the "
        "specified rect.")
    .def("clipRRect",
        py::overload_cast<const SkRRect&, SkClipOp, bool>(&SkCanvas::clipRRect),
        "Replaces clip with the intersection or difference of clip and rrect, "
        "with an aliased or anti-aliased clip edge.")
    .def("clipRRect",
        py::overload_cast<const SkRRect&, SkClipOp>(&SkCanvas::clipRRect),
        "Replaces clip with the intersection or difference of clip and rrect.")
    .def("clipRRect",
        py::overload_cast<const SkRRect&, bool>(&SkCanvas::clipRRect),
        "Replaces clip with the intersection of clip and rrect, with an "
        "aliased or anti-aliased clip edge.",
        py::arg("rrect"), py::arg("doAntiAlias") = false)
    .def("clipPath",
        py::overload_cast<const SkPath&, SkClipOp, bool>(&SkCanvas::clipPath),
        "Replaces clip with the intersection or difference of clip and path, "
        "with an aliased or anti-aliased clip edge.")
    .def("clipPath",
        py::overload_cast<const SkPath&, SkClipOp>(&SkCanvas::clipPath),
        "Replaces clip with the intersection or difference of clip and path.")
    .def("clipPath",
        py::overload_cast<const SkPath&, bool>(&SkCanvas::clipPath),
        "Replaces clip with the intersection of clip and path.",
        py::arg("path"), py::arg("doAntiAlias") = false)
    // .def("clipShader", &SkCanvas::clipShader)
    .def("clipRegion", &SkCanvas::clipRegion,
        "Replaces clip with the intersection or difference of clip and "
        "SkRegion deviceRgn.",
        py::arg("deviceRgn"), py::arg("op") = SkClipOp::kIntersect)
    .def("quickReject",
        py::overload_cast<const SkRect&>(&SkCanvas::quickReject, py::const_),
        "Returns true if SkRect rect, transformed by SkMatrix, can be quickly "
        "determined to be outside of clip.")
    .def("quickReject",
        py::overload_cast<const SkPath&>(&SkCanvas::quickReject, py::const_),
        "Returns true if path, transformed by SkMatrix, can be quickly "
        "determined to be outside of clip.")
    .def("getLocalClipBounds",
        py::overload_cast<>(&SkCanvas::getLocalClipBounds, py::const_),
        "Returns bounds of clip, transformed by inverse of SkMatrix.")
    .def("getLocalClipBounds",
        py::overload_cast<SkRect*>(&SkCanvas::getLocalClipBounds, py::const_),
        "Returns bounds of clip, transformed by inverse of SkMatrix.")
    .def("getDeviceClipBounds",
        py::overload_cast<>(&SkCanvas::getDeviceClipBounds, py::const_),
        "Returns SkIRect bounds of clip, unaffected by SkMatrix.")
    .def("getDeviceClipBounds",
        py::overload_cast<SkIRect*>(&SkCanvas::getDeviceClipBounds, py::const_),
        "Returns SkIRect bounds of clip, unaffected by SkMatrix.")
    .def("drawColor", &SkCanvas::drawColor, "Fills clip with color color.",
        py::arg("color"), py::arg("mode") = SkBlendMode::kSrcOver)
    .def("clear", &SkCanvas::clear,
        "Fills clip with color using SkBlendMode::kSrc")
    .def("discard", &SkCanvas::discard, "Makes SkCanvas contents undefined.")
    .def("drawPaint", &SkCanvas::drawPaint, "Fills clip with SkPaint paint.")
    .def("drawPoints",
        // &SkCanvas::drawPoints,
        [] (SkCanvas& canvas, SkCanvas::PointMode mode, py::iterable iterable,
            const SkPaint &paint) {
            std::vector<SkPoint> points;
            for (auto point : iterable) {
                points.push_back(*point.cast<SkPoint*>());
            }
            canvas.drawPoints(mode, points.size(), &points[0], paint);
        },
        R"docstring(
            Draws pts using clip, :py:class:`Matrix` and :py:class:`Paint`
            paint.

            mode may be one of: :py:attr:`~Canvas.PointMode.kPoints`,
            :py:attr:`~Canvas.PointMode.kLines`, or
            :py:attr:`~Canvas.PointMode.kPolygon`.

            If mode is :py:attr:`kPoints`, the shape of point drawn depends on
            paint :py:class:`Paint.Cap`. If paint is set to
            :py:attr:`Paint.kRound`, each point draws a circle of diameter
            :py:class:`Paint` stroke width. If paint is set to
            :py:attr:`Paint.kSquare` or :py:attr:`Paint.kButt`, each point
            draws a square of width and height :py:attr:`Paint` stroke width.

            If mode is :py:attr:`kLines`, each pair of points draws a line
            segment. One line is drawn for every two points; each point is used
            once. If count is odd, the final point is ignored.

            If mode is :py:attr:`kPolygon`, each adjacent pair of points draws a
            line segment. count minus one lines are drawn; the first and last
            point are used once.

            Each line segment respects paint :py:class:`Paint.Cap` and
            :py:class:`Paint` stroke width. :py:class:`Paint.Style` is
            ignored, as if were set to :py:attr:`Paint.kStroke`.

            Always draws each element one at a time; is not affected by
            :py:class:`Paint.Join`, and unlike :py:meth:`drawPath`, does not
            create a mask from all points and lines before drawing.

            :param skia.Canvas.PointMode mode: whether pts draws points or lines
            :param Iterable[skia.Point] pts: array of points to draw
            :param skia.Paint paint: stroke, blend, color, and so on, used to
                draw

        )docstring",
        py::arg("mode"), py::arg("pts"), py::arg("paint"))
    .def("drawPoint",
        py::overload_cast<SkScalar, SkScalar, const SkPaint&>(
            &SkCanvas::drawPoint),
        "Draws point at (x, y) using clip, SkMatrix and SkPaint paint.")
    .def("drawPoint",
        py::overload_cast<SkPoint, const SkPaint&>(&SkCanvas::drawPoint),
        "Draws point p using clip, SkMatrix and SkPaint paint.")
    .def("drawLine",
        py::overload_cast<SkScalar, SkScalar, SkScalar, SkScalar,
            const SkPaint&>(&SkCanvas::drawLine),
        "Draws line segment from (x0, y0) to (x1, y1) using clip, SkMatrix, "
        "and SkPaint paint.")
    .def("drawLine",
        py::overload_cast<SkPoint, SkPoint, const SkPaint&>(
            &SkCanvas::drawLine),
        "Draws line segment from p0 to p1 using clip, SkMatrix, and SkPaint "
        "paint.")
    .def("drawRect", &SkCanvas::drawRect,
        "Draws SkRect rect using clip, SkMatrix, and SkPaint paint.")
    .def("drawIRect", &SkCanvas::drawIRect,
        "Draws SkIRect rect using clip, SkMatrix, and SkPaint paint.")
    .def("drawRegion", &SkCanvas::drawRegion,
        "Draws SkRegion region using clip, SkMatrix, and SkPaint paint.")
    .def("drawOval", &SkCanvas::drawOval,
        "Draws oval oval using clip, SkMatrix, and SkPaint.")
    .def("drawRRect", &SkCanvas::drawRRect,
        "Draws SkRRect rrect using clip, SkMatrix, and SkPaint paint.")
    .def("drawDRRect", &SkCanvas::drawDRRect,
        "Draws SkRRect outer and inner using clip, SkMatrix, and SkPaint "
        "paint.")
    .def("drawCircle",
        py::overload_cast<SkScalar, SkScalar, SkScalar, const SkPaint&>(
            &SkCanvas::drawCircle),
        "Draws circle at (cx, cy) with radius using clip, SkMatrix, and "
        "SkPaint paint.")
    .def("drawCircle",
        py::overload_cast<SkPoint, SkScalar, const SkPaint&>(
            &SkCanvas::drawCircle),
        "Draws circle at center with radius using clip, SkMatrix, and SkPaint "
        "paint.")
    .def("drawArc", &SkCanvas::drawArc,
        "Draws arc using clip, SkMatrix, and SkPaint paint.")
    .def("drawRoundRect", &SkCanvas::drawRoundRect,
        "Draws SkRRect bounded by SkRect rect, with corner radii (rx, ry) "
        "using clip, SkMatrix, and SkPaint paint.")
    .def("drawPath", &SkCanvas::drawPath,
        "Draws SkPath path using clip, SkMatrix, and SkPaint paint.")
    .def("drawImage",
        py::overload_cast<const SkImage*, SkScalar, SkScalar,
            const SkPaint*>(&SkCanvas::drawImage),
        "Draws SkImage image, with its top-left corner at (left, top), using "
        "clip, SkMatrix, and optional SkPaint paint",
        py::arg("image"), py::arg("left"), py::arg("top"),
        py::arg("paint") = nullptr)
    .def("drawImage",
        py::overload_cast<const sk_sp<SkImage>&, SkScalar, SkScalar,
            const SkPaint*>(&SkCanvas::drawImage),
        "Draws SkImage image, with its top-left corner at (left, top), using "
        "clip, SkMatrix, and optional SkPaint paint",
        py::arg("image"), py::arg("left"), py::arg("top"),
        py::arg("paint") = nullptr)
    .def("drawImageRect",
        py::overload_cast<const SkImage*, const SkRect&, const SkRect&,
            const SkPaint*, SkCanvas::SrcRectConstraint>(
                &SkCanvas::drawImageRect),
        "Draws SkRect src of SkImage image, scaled and translated to fill "
        "SkRect dst.",
        py::arg("image"), py::arg("src"), py::arg("dst"),
        py::arg("paint") = nullptr, py::arg("constraint") =
            SkCanvas::SrcRectConstraint::kStrict_SrcRectConstraint)
    .def("drawImageRect",
        py::overload_cast<const SkImage*, const SkIRect&, const SkRect&,
            const SkPaint*, SkCanvas::SrcRectConstraint>(
            &SkCanvas::drawImageRect),
        "Draws SkIRect isrc of SkImage image, scaled and translated to fill "
        "SkRect dst.",
        py::arg("image"), py::arg("isrc"), py::arg("dst"),
        py::arg("paint") = nullptr, py::arg("constraint") =
            SkCanvas::SrcRectConstraint::kStrict_SrcRectConstraint)
    .def("drawImageRect",
        py::overload_cast<const SkImage*, const SkRect&, const SkPaint*>(
            &SkCanvas::drawImageRect),
        "Draws SkImage image, scaled and translated to fill SkRect dst, using "
        "clip, SkMatrix, and optional SkPaint paint.",
        py::arg("image"), py::arg("dst"), py::arg("paint") = nullptr)
    // .def("drawImageRect",
    //     py::overload_cast<const sk_sp<SkImage>&, const SkRect&, const SkRect&,
    //         const SkPaint*, SkCanvas::SrcRectConstraint>(
    //         &SkCanvas::drawImageRect),
    //     "Draws SkRect src of SkImage image, scaled and translated to fill "
    //     "SkRect dst.",
    //     py::arg("image"), py::arg("src"), py::arg("dst"), py::arg("paint"),
    //     py::arg("constraint") =
    //         SkCanvas::SrcRectConstraint::kStrict_SrcRectConstraint)
    // .def("drawImageRect",
    //     py::overload_cast<const sk_sp<SkImage>&, const SkIRect&,
    //         const SkRect&, const SkPaint*, SkCanvas::SrcRectConstraint))
    //     &SkCanvas::drawImageRect,
    //     "Draws SkIRect isrc of SkImage image, scaled and translated to fill "
    //     "SkRect dst.",
    //     py::arg("image"), py::arg("isrc"), py::arg("dst"), py::arg("paint"),
    //     py::arg("constraint") =
    //         SkCanvas::SrcRectConstraint::kStrict_SrcRectConstraint)
    // .def("drawImageRect",
    //     py::overload_cast<const sk_sp<SkImage>&, const SkRect&,
    //         const SkPaint*>(&SkCanvas::drawImageRect),
    //     "Draws SkImage image, scaled and translated to fill SkRect dst, using "
    //     "clip, SkMatrix, and optional SkPaint paint.")
    .def("drawImageNine",
        py::overload_cast<const SkImage*, const SkIRect&, const SkRect&,
            const SkPaint*>(&SkCanvas::drawImageNine),
        "Draws SkImage image stretched proportionally to fit into SkRect dst.",
        py::arg("image"), py::arg("center"), py::arg("dst"),
        py::arg("paint") = nullptr)
    // .def("drawImageNine",
    //     py::overload_cast<const sk_sp<SkImage>&, const SkIRect&,
    //         const SkRect&, const SkPaint*>(&SkCanvas::drawImageNine),
    //     "Draws SkImage image stretched proportionally to fit into SkRect dst.")
    .def("drawBitmap", &SkCanvas::drawBitmap,
        "Draws SkBitmap bitmap, with its top-left corner at (left, top), using "
        "clip, SkMatrix, and optional SkPaint paint.",
        py::arg("bitmap"), py::arg("left"), py::arg("top"),
        py::arg("paint") = nullptr)
    .def("drawBitmapRect",
        py::overload_cast<const SkBitmap&, const SkRect&, const SkRect&,
            const SkPaint*, SkCanvas::SrcRectConstraint>(
                &SkCanvas::drawBitmapRect),
        "Draws SkRect src of SkBitmap bitmap, scaled and translated to fill "
        "SkRect dst.",
        py::arg("bitmap"), py::arg("src"), py::arg("dst"),
        py::arg("paint") = nullptr, py::arg("constraint") =
            SkCanvas::SrcRectConstraint::kStrict_SrcRectConstraint)
    .def("drawBitmapRect",
        py::overload_cast<const SkBitmap&, const SkIRect&, const SkRect&,
            const SkPaint*, SkCanvas::SrcRectConstraint>(
                &SkCanvas::drawBitmapRect),
        "Draws SkIRect isrc of SkBitmap bitmap, scaled and translated to fill "
        "SkRect dst.",
        py::arg("bitmap"), py::arg("isrc"), py::arg("dst"),
        py::arg("paint") = nullptr, py::arg("constraint") =
            SkCanvas::SrcRectConstraint::kStrict_SrcRectConstraint)
    .def("drawBitmapRect",
        py::overload_cast<const SkBitmap&, const SkRect&, const SkPaint*,
            SkCanvas::SrcRectConstraint>(&SkCanvas::drawBitmapRect),
        "Draws SkBitmap bitmap, scaled and translated to fill SkRect dst.",
        py::arg("bitmap"), py::arg("dst"), py::arg("paint") = nullptr,
        py::arg("constraint") =
            SkCanvas::SrcRectConstraint::kStrict_SrcRectConstraint)
    // .def("drawImageLattice", &SkCanvas::drawImageLattice,
    //     "Draws SkImage image stretched proportionally to fit into SkRect dst.")
    // .def("experimental_DrawEdgeAAQuad",
    //     py::overload_cast<const SkRect&, const SkPoint[4],
    //         SkCanvas::QuadAAFlags, const SkColor4f&, SkBlendMode>(
    //             &SkCanvas::experimental_DrawEdgeAAQuad),
    //     "This is an experimental API for the SkiaRenderer Chromium project, "
    //     "and its API will surely evolve if it is not removed outright.")
    // .def("experimental_DrawEdgeAAQuad",
    //     py::overload_cast<const SkRect&, const SkPoint[4],
    //         SkCanvas::QuadAAFlags, SkColor, SkBlendMode>(
    //             &SkCanvas::experimental_DrawEdgeAAQuad))
    .def("drawSimpleText",
        // &SkCanvas::drawSimpleText,
        [] (SkCanvas& canvas, const std::string& text, SkScalar x, SkScalar y,
            const SkFont& font, const SkPaint& paint) {
            canvas.drawSimpleText(
                text.c_str(), text.size(), SkTextEncoding::kUTF8, x, y, font,
                paint);
        },
        R"docstring(
        Draws text, with origin at (x, y), using clip, :py:class:`Matrix`,
        :py:class:`Font` font, and :py:class:`Paint` paint.

        This function uses the default character-to-glyph mapping from the
        :py:class:`Typeface` in font. It does not perform typeface fallback for
        characters not found in the :py:class:`Typeface`. It does not perform
        kerning or other complex shaping; glyphs are positioned based on their
        default advances.

        Text size is affected by :py:class:`Matrix` and :py:class:`Font` text
        size. Default text size is 12 point.

        All elements of paint: :py:class:`PathEffect`, :py:class:`MaskFilter`,
        :py:class:`Shader`, :py:class:`ColorFilter`, :py:class:`ImageFilter`,
        and :py:class:`DrawLooper`; apply to text. By default, draws filled
        black glyphs.

        :param str text: character code points or glyphs drawn
        :param float x: start of text on x-axis
        :param float y: start of text on y-axis
        :param skia.Font font: typeface, text size and so, used to describe the
            text
        :param skia.Paint paint: blend, color, and so on, used to draw
        )docstring",
        py::arg("text"), py::arg("x"), py::arg("y"), py::arg("font"),
        py::arg("paint"))
    .def("drawString",
        // py::overload_cast<const char[], SkScalar, SkScalar, const SkFont&,
        //     const SkPaint&>(&SkCanvas::drawString),
        [] (SkCanvas& canvas, const std::string& text, SkScalar x, SkScalar y,
            const SkFont& font, const SkPaint& paint) {
            canvas.drawString(text.c_str(), x, y, font, paint);
        },
        R"docstring(
        Draws string, with origin at (x, y), using clip, :py:class:`Matrix`,
        :py:class:`Font` font, and :py:class:`Paint` paint.

        This function uses the default character-to-glyph mapping from the
        :py:class:`Typeface` in font. It does not perform typeface fallback for
        characters not found in the :py:class:`Typeface`. It does not perform
        kerning; glyphs are positioned based on their default advances.

        String `text` is encoded as UTF-8.

        Text size is affected by :py:class:`Matrix` and font text size. Default
        text size is 12 point.

        All elements of paint: :py:class:`PathEffect`, :py:class:`MaskFilter`,
        :py:class:`Shader`, :py:class:`ColorFilter`, :py:class:`ImageFilter`,
        and :py:class:`DrawLooper`; apply to text. By default, draws filled
        black glyphs.

        :param str text: character code points drawn, ending with a char value
            of zero
        :param float x: start of string on x-axis
        :param float y: start of string on y-axis
        :param skia.Font font: typeface, text size and so, used to describe the
            text
        :param skia.Paint paint: blend, color, and so on, used to draw
        )docstring",
        py::arg("text"), py::arg("x"), py::arg("y"), py::arg("font"),
        py::arg("paint"))
    // .def("drawString",
    //     py::overload_cast<const SkString&, SkScalar, SkScalar, const SkFont&,
    //         const SkPaint&>(&SkCanvas::drawString),
    //     "DDraws SkString, with origin at (x, y), using clip, SkMatrix, SkFont "
    //     "font, and SkPaint paint.")
    .def("drawTextBlob",
        py::overload_cast<const SkTextBlob*, SkScalar, SkScalar,
            const SkPaint&>(&SkCanvas::drawTextBlob),
        R"docstring(
        Draws :py:class:`TextBlob` blob at (x, y), using clip,
        :py:class:`Matrix`, and :py:class:`Paint` paint.

        `blob` contains glyphs, their positions, and paint attributes specific
        to text: :py:class:`Typeface`, :py:class:`Paint` text size,
        :py:class:`Paint` text scale x, :py:class:`Paint` text skew x,
        :py:class:`Paint`::Align, :py:class:`Paint`::Hinting, anti-alias,
        :py:class:`Paint` fake bold, :py:class:`Paint` font embedded bitmaps,
        :py:class:`Paint` full hinting spacing, LCD text, :py:class:`Paint`
        linear text, and :py:class:`Paint` subpixel text.

        :py:class:`TextEncoding` must be set to
        :py:attr:`TextEncoding.kGlyphID`.

        Elements of paint: anti-alias, :py:class:`BlendMode`, color including
        alpha, :py:class:`ColorFilter`, :py:class:`Paint` dither,
        :py:class:`DrawLooper`, :py:class:`MaskFilter`, :py:class:`PathEffect`,
        :py:class:`Shader`, and :py:class:`Paint.Style`; apply to blob. If
        :py:class:`Paint` contains :py:attr:`Paint.kStroke`: :py:class:`Paint`
        iter limit, :py:class:`Paint.Cap`, :py:class:`Paint.Join`, and
        :py:class:`Paint` stroke width; apply to :py:class:`Path` created from
        blob.

        :param skia.TextBlob blob: glyphs, positions, and their paints' text
            size, typeface, and so on
        :param float x: horizontal offset applied to blob
        :param float y: vertical offset applied to blob
        :param skia.Paint paint: blend, color, stroking, and so on, used to draw
        )docstring",
        py::arg("blob"), py::arg("x"), py::arg("y"), py::arg("paint"))
    // .def("drawTextBlob",
    //     py::overload_cast<const sk_sp<SkTextBlob>&, SkScalar, SkScalar,
    //         const SkPaint&>(&SkCanvas::drawTextBlob),
    //     "Draws SkTextBlob blob at (x, y), using clip, SkMatrix, and SkPaint "
    //     "paint.")
    // .def("drawPicture",
    //     py::overload_cast<const SkPicture*>(&SkCanvas::drawPicture))
    // .def("drawPicture",
    //     py::overload_cast<const sk_sp<SkPicture>&>(&SkCanvas::drawPicture),
    //     "Draws SkPicture picture, using clip and SkMatrix.")
    .def("drawPicture",
        py::overload_cast<const SkPicture*, const SkMatrix*, const SkPaint*>(
            &SkCanvas::drawPicture),
        R"docstring(
        Draws :py:class:`Picture` picture, using clip and :py:class:`Matrix`;
        transforming picture with :py:class:`Matrix` matrix, if provided; and
        use :py:class:`Paint` paint alpha, :py:class:`ColorFilter`,
        :py:class:`ImageFilter`, and :py:class:`BlendMode`, if provided.

        :py:class:`Picture` records a series of draw commands for later
        playback.

        matrix transformation is equivalent to: save(), concat(), drawPicture(),
        restore(). paint use is equivalent to: saveLayer(), drawPicture(),
        restore().

        :param skia.Picture picture: recorded drawing commands to play
        :param skia.Matrix matrix:  :py:class:`Matrix` to rotate, scale,
            translate, and so on; may be `None`
        :param skia.Paint paint: :py:class:`Paint` to apply transparency,
            filtering, and so on; may be `None`
        )docstring",
        py::arg("picture"), py::arg("matrix") = nullptr,
        py::arg("paint") = nullptr)
    // .def("drawPicture",
    //     py::overload_cast<const sk_sp<SkPicture>&, const SkMatrix*,
    //         const SkPaint*>(&SkCanvas::drawPicture),
    //     "Draws SkPicture picture, using clip and SkMatrix; transforming "
    //     "picture with SkMatrix matrix, if provided; and use SkPaint paint "
    //     "alpha, SkColorFilter, SkImageFilter, and SkBlendMode, if provided.")
    .def("drawVertices",
        // py::overload_cast<const SkVertices*, SkBlendMode, const SkPaint&>(
        //     &SkCanvas::drawVertices),
        [] (SkCanvas& canvas, const SkVertices* vertices, const SkPaint& paint,
            SkBlendMode mode) { canvas.drawVertices(vertices, mode, paint); },
        R"docstring(
        Draws :py:class:`Vertices` vertices, a triangle mesh, using clip and
        :py:class:`Matrix`.

        If vertices texs and vertices colors are defined in vertices, and
        :py:class:`Paint` paint contains :py:class:`Shader`,
        :py:class:`BlendMode` mode combines vertices colors with
        :py:class:`Shader`.

        :param skia.Vertices vertices: triangle mesh to draw
        :param skia.BlendMode mode: combines vertices colors with
            :py:class:`Shader`, if both are present
        :param skia.Paint paint: specifies the :py:class:`Shader`, used as
            :py:class:`Vertices` texture
        )docstring",
        py::arg("vertices"), py::arg("paint"),
        py::arg("mode") = SkBlendMode::kModulate)
    // .def("drawVertices",
    //     py::overload_cast<const SkVertices*, const SkPaint&>(
    //         &SkCanvas::drawVertices),
    //     "Variant of 3-parameter drawVertices, using the default of Modulate "
    //     "for the blend parameter.")
    // .def("drawVertices",
    //     py::overload_cast<const sk_sp<SkVertices>&, SkBlendMode,
    //         const SkPaint&>(&SkCanvas::drawVertices),
    //     "Draws SkVertices vertices, a triangle mesh, using clip and SkMatrix.")
    // .def("drawVertices",
    //     py::overload_cast<const sk_sp<SkVertices>&, const SkPaint&>(
    //         &SkCanvas::drawVertices),
    //     "Variant of 3-parameter drawVertices, using the default of Modulate "
    //     "for the blend parameter.")
    .def("drawPatch",
        py::overload_cast<const SkPoint[12], const SkColor[4],
            const SkPoint[4], SkBlendMode, const SkPaint&>(
                &SkCanvas::drawPatch),
        "Draws a Coons patch: the interpolation of four cubics with shared "
        "corners, associating a color, and optionally a texture SkPoint, with "
        "each corner.")
    .def("drawPatch",
        py::overload_cast<const SkPoint[12], const SkColor[4],
            const SkPoint[4], const SkPaint&>(
                &SkCanvas::drawPatch),
        "Draws SkPath cubic Coons patch: the interpolation of four cubics with "
        "shared corners, associating a color, and optionally a texture "
        "SkPoint, with each corner.")
    .def("drawAtlas",
        py::overload_cast<const SkImage*, const SkRSXform[], const SkRect[],
            const SkColor[], int, SkBlendMode, const SkRect*, const SkPaint*>(
                &SkCanvas::drawAtlas),
        "Draws a set of sprites from atlas, using clip, SkMatrix, and optional "
        "SkPaint paint.")
    .def("drawAtlas",
        py::overload_cast<const sk_sp<SkImage>&, const SkRSXform[],
            const SkRect[], const SkColor[], int, SkBlendMode, const SkRect*,
            const SkPaint*>(&SkCanvas::drawAtlas),
        "Draws a set of sprites from atlas, using clip, SkMatrix, and optional "
        "SkPaint paint.")
    .def("drawAtlas",
        py::overload_cast<const SkImage*, const SkRSXform[], const SkRect[],
            int, const SkRect*, const SkPaint*>(
                &SkCanvas::drawAtlas),
        "Draws a set of sprites from atlas, using clip, SkMatrix, and optional "
        "SkPaint paint.")
    .def("drawAtlas",
        py::overload_cast<const sk_sp<SkImage>&, const SkRSXform[],
            const SkRect[], int, const SkRect*, const SkPaint*>(
                &SkCanvas::drawAtlas),
        "Draws a set of sprites from atlas, using clip, SkMatrix, and optional "
        "SkPaint paint.")
    /*
    .def("drawDrawable",
        py::overload_cast<SkDrawable*, const SkMatrix*>(
            &SkCanvas::drawDrawable),
        "Draws SkDrawable drawable using clip and SkMatrix, concatenated with "
        "optional matrix.")
    .def("drawDrawable",
        py::overload_cast<SkDrawable*, SkScalar, SkScalar>(
            &SkCanvas::drawDrawable),
        "Draws SkDrawable drawable using clip and SkMatrix, offset by (x, y).")
    */
    .def("drawAnnotation",
        py::overload_cast<const SkRect&, const char[], SkData*>(
            &SkCanvas::drawAnnotation),
        "Associates SkRect on SkCanvas with an annotation; a key-value pair, "
        "where the key is a null-terminated UTF-8 string, and optional value "
        "is stored as SkData.")
    .def("drawAnnotation",
        py::overload_cast<const SkRect&, const char[], const sk_sp<SkData>&>(
            &SkCanvas::drawAnnotation),
        "Associates SkRect on SkCanvas when an annotation; a key-value pair, "
        "where the key is a null-terminated UTF-8 string, and optional value "
        "is stored as SkData.")
    .def("isClipEmpty", &SkCanvas::isClipEmpty,
        "Returns true if clip is empty; that is, nothing will draw.")
    .def("isClipRect", &SkCanvas::isClipRect,
        "Returns true if clip is SkRect and not empty.")
    .def("getTotalMatrix", &SkCanvas::getTotalMatrix, "Returns SkMatrix.")
    .def("getLocalToDevice",
        py::overload_cast<>(&SkCanvas::getLocalToDevice, py::const_))
    .def("getLocalToDevice",
        py::overload_cast<SkScalar[16]>(
            &SkCanvas::getLocalToDevice, py::const_))
    .def("experimental_getLocalToWorld",
        py::overload_cast<>(
            &SkCanvas::experimental_getLocalToWorld, py::const_))
    .def("experimental_getLocalToCamera",
        py::overload_cast<>(
            &SkCanvas::experimental_getLocalToCamera, py::const_))
    .def("experimental_getLocalToCamera",
        py::overload_cast<SkScalar[16]>(
            &SkCanvas::experimental_getLocalToCamera, py::const_))
    .def("experimental_getLocalToWorld",
        py::overload_cast<SkScalar[16]>(
            &SkCanvas::experimental_getLocalToWorld, py::const_))
    // Static methods.
    .def_static("MakeRasterDirect", &SkCanvas::MakeRasterDirect,
        "Allocates raster SkCanvas that will draw directly into pixels.")
    .def_static("MakeRasterDirectN32", &SkCanvas::MakeRasterDirectN32,
        "Allocates raster SkCanvas specified by inline image specification.")
    ;
}
