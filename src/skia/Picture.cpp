#include "common.h"

class PyPicture : public SkPicture {
public:
    void playback(
        SkCanvas *canvas, SkPicture::AbortCallback *callback=nullptr
        ) const override {
        PYBIND11_OVERLOAD_PURE(void, SkPicture, playback, canvas, callback);
    }
    SkRect cullRect() const override {
        PYBIND11_OVERLOAD_PURE(SkRect, SkPicture, cullRect);
    }
    int approximateOpCount() const override {
        PYBIND11_OVERLOAD_PURE(int, SkPicture, approximateOpCount);
    }
    size_t approximateBytesUsed() const override {
        PYBIND11_OVERLOAD_PURE(size_t, SkPicture, approximateBytesUsed);
    }
};

class PyBBoxHierarchy : public SkBBoxHierarchy {
public:
    using SkBBoxHierarchy::SkBBoxHierarchy;
    void insert(const SkRect rects[], int N) override {
        PYBIND11_OVERLOAD_PURE(void, SkBBoxHierarchy, insert, rects, N);
    }
    void search(const SkRect& query, std::vector<int> *results) const override {
        PYBIND11_OVERLOAD_PURE(void, SkBBoxHierarchy, search, query, results);
    }
    size_t bytesUsed() const override {
        PYBIND11_OVERLOAD_PURE(size_t, SkBBoxHierarchy, bytesUsed);
    }
};

void initPicture(py::module &m) {
py::class_<SkPicture, PyPicture, sk_sp<SkPicture>, SkRefCnt>(
    m, "Picture", R"docstring(
    :py:class:`Picture` records drawing commands made to :py:class:`Canvas`.

    The command stream may be played in whole or in part at a later time.

    :py:class:`Picture` is an abstract class. :py:class:`Picture` may be
    generated by :py:class:`PictureRecorder` or :py:class:`Drawable`, or from
    :py:class:`Picture` previously saved to :py:class:`Data` or
    :py:class:`Stream`.

    :py:class:`Picture` may contain any :py:class:`Canvas` drawing command, as
    well as one or more :py:class:`Canvas` matrix or :py:class:`Canvas` clip.
    :py:class:`Picture` has a cull :py:class:`Rect`, which is used as a bounding
    box hint. To limit :py:class:`Picture` bounds, use :py:class:`Canvas` clip
    when recording or drawing :py:class:`Picture`.
    )docstring")
    .def(py::init(&SkPicture::MakePlaceholder))
    .def("playback", &SkPicture::playback,
        "Replays the drawing commands on the specified canvas.")
    .def("cullRect", &SkPicture::cullRect,
        "Returns cull SkRect for this picture, passed in when SkPicture was "
        "created.")
    .def("uniqueID", &SkPicture::uniqueID,
        "Returns a non-zero value unique among SkPicture in Skia process.")
    .def("serialize",
        // py::overload_cast<const SkSerialProcs*>(&SkPicture::serialize),
        [] (SkPicture& picture) { return picture.serialize(); },
        "Returns storage containing SkData describing SkPicture, using "
        "optional custom encoders.")
    // .def("serialize",
    //     py::overload_cast<SkWStream*, const SkSerialProcs*>(
    //         &SkPicture::serialize),
    //     "Writes picture to stream, using optional custom encoders.")
    .def("approximateOpCount", &SkPicture::approximateOpCount,
        "Returns the approximate number of operations in SkPicture.")
    .def("approximateBytesUsed", &SkPicture::approximateBytesUsed,
        "Returns the approximate byte size of SkPicture.")
    .def("makeShader",
        py::overload_cast<SkTileMode, SkTileMode, const SkMatrix*,
            const SkRect*>(&SkPicture::makeShader, py::const_),
        "Return a new shader that will draw with this picture.")
    .def("makeShader",
        py::overload_cast<SkTileMode, SkTileMode, const SkMatrix*>(
            &SkPicture::makeShader, py::const_))
    // .def_static("MakeFromStream", &SkPicture::MakeFromStream,
    //     "Recreates SkPicture that was serialized into a stream.")
    // .def_static("MakeFromData",
    //     py::overload_cast<const SkData*, const SkDeserialProcs*>(
    //         &SkPicture::MakeFromData),
    //     "Recreates SkPicture that was serialized into data.")
    // .def_static("MakeFromData",
    //     py::overload_cast<const void*, size_t, const SkDeserialProcs*>(
    //         &SkPicture::MakeFromData))
    .def_static("MakePlaceholder", &SkPicture::MakePlaceholder,
        "Returns a placeholder SkPicture.")
    ;

py::class_<SkBBHFactory>(m, "BBHFactory");

py::class_<SkBBoxHierarchy, PyBBoxHierarchy, sk_sp<SkBBoxHierarchy>, SkRefCnt>
    bboxhierarchy(m, "BBoxHierarchy");

py::class_<SkBBoxHierarchy::Metadata>(bboxhierarchy, "Metadata")
    .def_readwrite("isDraw", &SkBBoxHierarchy::Metadata::isDraw);

bboxhierarchy
    .def(py::init())
    .def("insert",
        py::overload_cast<const SkRect[], int>(&SkBBoxHierarchy::insert),
        "Insert N bounding boxes into the hierarchy.")
    .def("insert",
        py::overload_cast<const SkRect[], const SkBBoxHierarchy::Metadata[],
            int>(&SkBBoxHierarchy::insert))
    .def("search", &SkBBoxHierarchy::search,
        "Populate results with the indices of bounding boxes intersecting "
        "that query.")
    .def("bytesUsed", &SkBBoxHierarchy::bytesUsed,
        "Return approximate size in memory of this.")
    ;

py::class_<SkPictureRecorder> picturerecorder(m, "PictureRecorder");

py::enum_<SkPictureRecorder::RecordFlags>(picturerecorder, "RecordFlags")
    .value("kPlaybackDrawPicture_RecordFlag",
        SkPictureRecorder::RecordFlags::kPlaybackDrawPicture_RecordFlag)
    .export_values();

py::enum_<SkPictureRecorder::FinishFlags>(picturerecorder, "FinishFlags");

picturerecorder
    .def(py::init())
    // .def("beginRecording",
    //     py::overload_cast<const SkRect&, sk_sp<SkBBoxHierarchy>, uint32_t>(
    //         &SkPictureRecorder::beginRecording),
    //     "Returns the canvas that records the drawing commands.")
    .def("beginRecording",
        py::overload_cast<const SkRect&, SkBBHFactory*, uint32_t>(
            &SkPictureRecorder::beginRecording),
        py::arg("bounds"), py::arg("bbhFactory") = nullptr,
        py::arg("recordFlags") = 0)
    .def("beginRecording",
        py::overload_cast<SkScalar, SkScalar, SkBBHFactory*, uint32_t>(
            &SkPictureRecorder::beginRecording),
        py::arg("width"), py::arg("height"), py::arg("bbhFactory") = nullptr,
        py::arg("recordFlags") = 0,
        py::return_value_policy::reference)
    .def("getRecordingCanvas", &SkPictureRecorder::getRecordingCanvas,
        "Returns the recording canvas if one is active, or NULL if recording "
        "is not active.",
        py::return_value_policy::reference)
    .def("finishRecordingAsPicture",
        &SkPictureRecorder::finishRecordingAsPicture,
        "Signal that the caller is done recording.",
        py::arg("endFlags") = 0)
    .def("finishRecordingAsPictureWithCull",
        &SkPictureRecorder::finishRecordingAsPictureWithCull,
        "Signal that the caller is done recording, and update the cull rect "
        "to use for bounding box hierarchy (BBH) generation.",
        py::arg("cullRect"), py::arg("endFlags") = 0)
    .def("finishRecordingAsDrawable",
        &SkPictureRecorder::finishRecordingAsDrawable,
        "Signal that the caller is done recording.",
        py::arg("endFlags") = 0)
    ;
}
